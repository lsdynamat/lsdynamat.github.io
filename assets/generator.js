function esc(s){ return (s ?? "").toString(); }

function downloadText(filename, text){
  const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(a.href);
}

function padLeft(str, width){ str = esc(str); return str.length >= width ? str : " ".repeat(width - str.length) + str; }
function fmtInt(x, width=10){ return padLeft(String(Math.trunc(Number(x))), width); }
function fmtNum(x, decimals, width=10){
  const n = Number(x);
  const s = Number.isFinite(n) ? n.toFixed(decimals) : "";
  return padLeft(s, width);
}

function getQuery(){
  const sp = new URLSearchParams(location.search);
  const o = {};
  for (const [k,v] of sp.entries()) o[k]=v;
  return o;
}

function setFieldValue(formWrap, key, value){
  const el = formWrap.querySelector(`[data-key="${CSS.escape(key)}"]`);
  if (el) el.value = value;
}

async function loadJson(url){
  const res = await fetch(url, { cache:"no-store" });
  if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.url}`);
  return res.json();
}

/* ---------- CSCM (ported) ---------- */
function cscm_fracture_energy(fc, dmax=16){
  const delta_f = 8;
  const fcm = fc + delta_f;
  const fcm0 = 10;
  const GF0 = 0.021 + 5.357e-4 * dmax;
  const GF  = GF0 * Math.pow((fcm / fcm0), 0.7);
  return { GF0, GF };
}

function cscm_modulus(fc){
  const Ec0 = 21.5e3;
  const delta_f = 8;
  const fcm = fc + delta_f;
  const fcm0 = 10;
  const nu = 0.2;
  const E = Ec0 * Math.pow(((fcm + delta_f) / fcm0), 1/3);
  const G = E / (2 * (1 + nu));
  const K = E / (3 * (1 - 2 * nu));
  return { G, K };
}

function cscm_alpha_beta(fc){
  const alpha = 13.9846 * Math.exp(fc / 68.8756) - 13.8981;
  const theta = 0.3533 - 3.3294e-4 * fc - 3.8182e-6 * (fc**2);
  const lamda = 3.6657 * Math.exp(fc / 39.9363) - 4.7092;
  const beta  = 18.17791 * (fc ** (-1.7163));

  const alpha1 = 0.82, theta1 = 0.0, lamda1 = 0.24, beta1 = 0.33565 * (fc ** (-0.95383));
  const alpha2 = 0.76, theta2 = 0.0, lamda2 = 0.26, beta2 = 0.285   * (fc ** (-0.94843));

  return { alpha, theta, lamda, beta, alpha1, theta1, lamda1, beta1, alpha2, theta2, lamda2, beta2 };
}

function cscm_r_xd(fc){
  const R  = 4.45994 * Math.exp(-fc / 11.51679) + 1.95358;
  const XD = 17.087 + 1.892 * fc;
  return { R, XD };
}

function cscm_additional(fc){
  const fpsi = fc * 145.038;
  const eta0c = (1.2772337e-11 * (fpsi ** 2) - 1.0613722e-7 * fpsi + 3.203497e-4);
  const nc = 0.78;

  const eta0t = (8.0614774e-13 * (fc ** 2) - 9.77736719e-10 * fc + 5.0752351e-5);
  const nt = 0.48;

  const overc = 1.309663e-2 * (fc ** 2) - 0.3927659 * fc + 21.45;
  const overt = 1.309663e-2 * (fc ** 2) - 0.3927659 * fc + 21.45;

  return { eta0c, nc, eta0t, nt, overc, overt, srate:1.0, repow:1.0 };
}

function generateCSCM(values){
  const MID  = Number(values.MID);
  const RO   = Number(values.RO);
  const fc   = Number(values.FC);
  const dmax = Number(values.DMAX);

  const { GF } = cscm_fracture_energy(fc, dmax);
  const { G, K } = cscm_modulus(fc);
  const ab = cscm_alpha_beta(fc);
  const { R, XD } = cscm_r_xd(fc);
  const ad = cscm_additional(fc);

  const GFC = 100 * GF, GFT = GF, GFS = GF;
  const B=100, D=0.1, PWRC=5, PWRT=1, PMOD=0;
  const W=0.065, D1=0.000611, D2=0.000002;

  const L = [];
  L.push("*KEYWORD");
  L.push("*MAT_CSCM_TITLE");
  L.push(`$ Name: Concrete, f_c = ${fc} MPa, agg.size = ${dmax} mm`);
  L.push("$ Units: mm-ms-g-N-MPa");
  L.push("$ Model: Continuous Surface Cap Model (CSCM) - MAT_159");
  L.push("$ Reference: Novozhilov Y.V., Dmitriev A.N., Mikhaluk D.S. Precise Calibration");
  L.push("$ of the Continuous Surface Cap Model for Concrete Simulation. Buildings. 2022.");
  L.push("$ doi:10.3390/buildings12050636");
  L.push("$ Generated by LS-DYNA Material Hub http://lsdynamat.github.io");
  L.push(`Concrete, f_c = ${fc} MPa, agg.size = ${dmax} mm`);

  L.push(
    fmtInt(MID) +
    fmtNum(RO, 4) +
    fmtInt(1) +
    padLeft("0.0", 10) +
    fmtInt(0) +
    padLeft("1.05", 10) +
    padLeft("0.0", 10) +
    fmtInt(0)
  );

  L.push(fmtNum(0.0, 1));

  L.push(
    fmtNum(G, 1) +
    fmtNum(K, 1) +
    fmtNum(ab.alpha, 4) +
    fmtNum(ab.theta, 7) +
    fmtNum(ab.lamda, 5) +
    fmtNum(ab.beta, 7) +
    fmtNum(0.0, 1) +
    fmtNum(0.0, 1)
  );

  L.push(
    fmtNum(ab.alpha1, 2) +
    fmtNum(ab.theta1, 1) +
    fmtNum(ab.lamda1, 2) +
    fmtNum(ab.beta1, 6) +
    fmtNum(ab.alpha2, 2) +
    fmtNum(ab.theta2, 1) +
    fmtNum(ab.lamda2, 2) +
    fmtNum(ab.beta2, 7)
  );

  L.push(
    fmtNum(R, 5) +
    fmtNum(XD, 3) +
    fmtNum(W, 3) +
    fmtNum(D1, 6) +
    fmtNum(D2, 6)
  );

  L.push(
    fmtNum(B, 1) +
    fmtNum(GFC, 1) +
    fmtNum(D, 1) +
    fmtNum(GFT, 2) +
    fmtNum(GFS, 2) +
    fmtNum(PWRC, 1) +
    fmtNum(PWRT, 1) +
    fmtNum(PMOD, 1)
  );

  L.push(
    fmtNum(ad.eta0c, 7) +
    fmtNum(ad.nc, 2) +
    fmtNum(ad.eta0t, 7) +
    fmtNum(ad.nt, 2) +
    fmtNum(ad.overc, 5) +
    fmtNum(ad.overt, 5) +
    fmtNum(ad.srate, 1) +
    fmtNum(ad.repow, 1)
  );

  L.push("*END");
  return { text: L.join("\n") + "\n", fileName: `MAT_CSCM_${fc}MPa.k` };
}

/* ---------- Winfrith generator ---------- */
function winfrith_tm(fc){
  const Ec0 = 21.5e3;
  const delta_f = 8;
  const fcm0 = 10;
  return Ec0 * Math.pow(((fc + delta_f) / fcm0), (1/3));
}
function winfrith_ft(fc){
  if (fc <= 50) return 0.3 * Math.pow(fc, 2/3);
  return 2.12 * Math.log(1 + 0.1 * (fc + 8));
}
function winfrith_gf0(dmax){ return 0.021 + 5.357e-4 * dmax; }
function winfrith_gf(fc, dmax){
  const fcm = fc + 8;
  const gf0 = winfrith_gf0(dmax);
  return gf0 * Math.pow((fcm / 10), 0.7);
}
function winfrith_wc(fc, dmax){
  const ft = winfrith_ft(fc);
  const gf = winfrith_gf(fc, dmax);
  return (2 * gf) / ft;
}

function generateWinfrith(values){
  const MID  = Number(values.MID);
  const RO   = Number(values.RO);
  const fc   = Number(values.FC);
  const dmax = Number(values.DMAX);

  const TM = winfrith_tm(fc);
  const UTS = winfrith_ft(fc);
  const FE = winfrith_wc(fc, dmax);
  const ASIZE = dmax / 2;

  const E=0.0, YS=0.0, EH=0.0, UELONG=0.0, RATE=1.0, CONM=-3.0, CONL=0.0, CONT=0.0;
  const eps = Array(8).fill(0.0);
  const p = Array(8).fill(0.0);

  const L = [];
  L.push("*KEYWORD");
  L.push("*MAT_WINFRITH_CONCRETE_TITLE");
  L.push(`$ Name: Concrete, f_c = ${fc} MPa, agg.size = ${dmax} mm`);
  L.push("$ Units: mm-ms-g-N-MPa");
  L.push("$ Model: Winfrith Concrete - MAT_084/085");
  L.push("$ Generated by LS-DYNA Material Hub http://lsdynamat.github.io");
  L.push(`WINFRITH_Concrete_${fc}MPa_dmax_${dmax}mm`);

  L.push("$#     mid        ro        tm        pr       ucs       uts        fe     asize");
  L.push(
    fmtInt(MID) +
    fmtNum(RO, 4) +
    fmtNum(TM, 1) +
    fmtNum(0.2, 1) +
    fmtNum(fc, 1) +
    fmtNum(UTS, 3) +
    fmtNum(FE, 3) +
    fmtNum(ASIZE, 1)
  );

  L.push("$#      e        ys        eh    uelong      rate      conm      conl      cont");
  L.push(
    fmtNum(E, 1) +
    fmtNum(YS, 1) +
    fmtNum(EH, 1) +
    fmtNum(UELONG, 1) +
    fmtNum(RATE, 1) +
    fmtNum(CONM, 1) +
    fmtNum(CONL, 1) +
    fmtNum(CONT, 3)
  );

  L.push("$#    eps1      eps2      eps3      eps4      eps5      eps6      eps7      eps8");
  L.push(eps.map(x => fmtNum(x, 1)).join(""));

  L.push("$#      p1        p2        p3        p4        p5        p6        p7        p8");
  L.push(p.map(x => fmtNum(x, 1)).join(""));

  L.push("*END");
  return { text: L.join("\n") + "\n", fileName: `MAT_WINFRITH_${fc}MPa.k` };
}

/* ---------- App ---------- */
async function init(){
  const year = document.getElementById("year");
  if (year) year.textContent = new Date().getFullYear();

  const modelSel = document.getElementById("modelSel");
  const formWrap = document.getElementById("formWrap");
  const preview = document.getElementById("preview");
  const dlBtn = document.getElementById("downloadBtn");
  const copyBtn = document.getElementById("copyBtn");
  const fileNameText = document.getElementById("fileNameText");

  const templates = await loadJson(new URL("../data/templates.json", document.baseURI));

  for (const t of templates){
    const opt = document.createElement("option");
    opt.value = t.id;
    opt.textContent = t.title;
    modelSel.appendChild(opt);
  }

  const query = getQuery();
  modelSel.value = query.id || templates[0]?.id;

  let current = null;

  function collectValues(){
    const values = {};
    for (const f of (current.fields || [])){
      const el = formWrap.querySelector(`[data-key="${CSS.escape(f.key)}"]`);
      values[f.key] = el ? el.value : "";
    }
    return values;
  }

  function compute(values){
    if (current.generator === "cscm") return generateCSCM(values);
    if (current.generator === "winfrith") return generateWinfrith(values);
    return { text:"", fileName: `${current.id}.k` };
  }

  function update(){
    const out = compute(collectValues());
    preview.textContent = out.text;
    fileNameText.textContent = out.fileName || "";
  }

  function renderForm(){
    current = templates.find(x => x.id === modelSel.value);
    if (!current) return;

    formWrap.innerHTML = (current.fields || []).map(f => {
      const val = (query[f.key] ?? f.default ?? "");
      const inputType = (f.type === "int" || f.type === "number") ? "number" : "text";
      const step = (f.type === "int") ? "1" : "any";
      const unit = f.unit ? `<span class="pill">${esc(f.unit)}</span>` : "";

      return `
        <div class="card">
          <div class="pills" style="margin-bottom:10px">
            <span class="pill">${esc(f.label)}</span>
            ${unit}
          </div>
          <input
            class="input"
            style="width:100%"
            data-key="${esc(f.key)}"
            name="${esc(f.key)}"
            type="${inputType}"
            step="${step}"
            value="${esc(val)}"
            ${f.required ? "required" : ""}
          />
        </div>
      `;
    }).join("");

    update();
  }

  modelSel.addEventListener("change", () => {
    history.replaceState(null, "", location.pathname + "?id=" + encodeURIComponent(modelSel.value));
    renderForm();
  });

  formWrap.addEventListener("input", update);

  dlBtn.addEventListener("click", () => {
    const out = compute(collectValues());
    downloadText(out.fileName, out.text);
  });

  copyBtn.addEventListener("click", async () => {
    try{
      await navigator.clipboard.writeText(preview.textContent || "");
      copyBtn.textContent = "Copied";
      setTimeout(()=>copyBtn.textContent="Copy", 1000);
    } catch {
      copyBtn.textContent = "Copy failed";
      setTimeout(()=>copyBtn.textContent="Copy", 1200);
    }
  });

  renderForm();
}

init().catch((e) => {
  console.error(e);
  const preview = document.getElementById("preview");
  if (preview) preview.textContent = e?.message || "Could not load templates.json";
});
