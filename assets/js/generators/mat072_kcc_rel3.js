// assets/js/generators/mat072_kcc_rel3.js
// KCC (K&C Damage Release 3) — *MAT_CONCRETE_DAMAGE_REL3
// Ported from your Python script (source of truth), plots removed.
// Units: mm-ms-g-N-MPa
// Generated by LS DYNA Material Hub http://lsdynamat.github.io

export const KEY = "mat072_kcc_rel3";
export const ID = 72;
export const NAME = "K&C Damage Release 3 (*MAT_CONCRETE_DAMAGE_REL3)";
export const CATEGORY = "Concrete";
export const UNITS = "mm-ms-g-N-MPa";

const UNITS_LINE = "$ Units: mm-ms-g-N-MPa";
const HUB_LINE = "$ Generated by LS DYNA Material Hub http://lsdynamat.github.io";

// Reference block (you can edit later)
const REF_LINES = [
  "$ Model: K&C Damage Release 3 - *MAT_CONCRETE_DAMAGE_REL3",
];

// Defaults for UI
export const DEFAULTS = {
  mid: 1,
  fc: 25.0,        // MPa
  elm_size: 25.0,  // mm
  omega: 0.5,      // -
  ro: 0.0023,      // g/mm^3 (typical concrete)
  pr: 0.16,        // Poisson in your Python used as phr=0.16
};

// If your UI reads "inputs" from materials.json, this is optional.
// Keep it for docs / later auto-sync.
export const FIELDS = [
  { key: "mid", label: "Material ID (MID)", unit: "-", default: DEFAULTS.mid, min: 1, hint: "Example: 1" },
  { key: "fc", label: "Compressive strength (fc)", unit: "MPa", default: DEFAULTS.fc, min: 1, hint: "Example: 25" },
  { key: "elm_size", label: "Element size", unit: "mm", default: DEFAULTS.elm_size, min: 1, hint: "Example: 25" },
  { key: "omega", label: "Omega (ω)", unit: "-", default: DEFAULTS.omega, min: 0, max: 1, hint: "Example: 0.5" },
  { key: "ro", label: "Density (RO)", unit: "g/mm^3", default: DEFAULTS.ro, min: 1e-6, hint: "Typical: 0.0023" },
  { key: "pr", label: "Poisson ratio (PR)", unit: "-", default: DEFAULTS.pr, min: 0.0, max: 0.49, hint: "Python uses 0.16" },
];

export function generate(input = {}) {
  const inp = { ...DEFAULTS, ...normalizeInput(input) };

  const mid = mustIntPositive("mid", inp.mid);
  const fc_mpa = mustPositive("fc", inp.fc);
  const elm_size_mm = mustPositive("elm_size", inp.elm_size);
  const omega = mustInRange("omega", inp.omega, 0.0, 1.0);
  const ro = mustPositive("ro", inp.ro);
  const pr = mustInRange("pr", inp.pr, 0.0, 0.49);

  // --- Python constants / conversions
  // In python:
  // MPA = 0.00689476 (psi -> MPa)
  // fc_input = fc / MPA => MPa -> psi
  // INCH = 25.4 (inch -> mm)
  const MPA = 0.00689476;
  const INCH = 25.4;

  const fc_psi = fc_mpa / MPA;             // MPa -> psi (as in Python)
  const mesh_size_in = elm_size_mm / INCH; // mm -> inch

  // --- Python per-material constants
  const lcrate = 1000 + mid;
  const eosid = lcrate;

  // In python:
  // phr = 0.16
  // density = 2.17e-4  (internal, but output uses densitySI=0.0023)
  // agg_size = 1/2 (inches)
  const phr = pr;          // use UI pr but default = 0.16
  const agg_size = 0.5;    // inch
  const W = 3 * agg_size;  // inch

  // --- Basic properties (psi)
  // ft = 6.7*sqrt(fc) but then override: ft=554
  const ftm = 6.7 * Math.sqrt(Math.abs(fc_psi)); // stored as ftm in Python
  const Ec = 57000 * Math.sqrt(Math.abs(fc_psi));
  // Eo used but not written to keyword; kept for completeness
  // const Eo = Ec * Math.pow(Math.abs(fc_psi) / 10, 1/3);

  // override
  const fc_old = 6580;
  const ft = 554; // psi override (as in Python)

  // --- Surface parameters
  const a0m = 1945, a1m = 0.4463, a2m = 1.228e-5;
  const a0y = 1469, a1y = 0.6250, a2y = 3.913e-5;
  const a1f = 0.447, a2f = 1.797e-5;

  // New model scaling
  const r = fc_psi / fc_old;
  const a0mn_psi = a0m * r;
  const a1mn = a1m;
  const a2mn_psiInv = a2m / r;

  const a0yn_psi = a0y * r;
  const a1yn = a1y;
  const a2yn_psiInv = a2y / r;

  const a1fn = a1mn;
  const a2fn_psiInv = a2mn_psiInv;

  // Softening parameters
  const b1 = 1.6;
  // b11 computed in Python but not used in writing
  // const b11 = 0.34 * mesh_size_in + 0.79;
  const b2 =
    (0.09 * (W ** 2) - 0.98 * W + 3.06) *
    (1 - 0.004 * ((fc_psi / 1000) ** 2) + 0.097 * (fc_psi / 1000) - 0.484);
  const b3 = 1.15;

  // --- Default lambda/eta vectors (as written in Python output)
  const lambda_default = [
    0.000e+0, 8.000e-6, 2.400e-5, 4.000e-5, 5.600e-5,
    7.200e-5, 1.000e-4, 1.000e-3, 3.000e-3, 5.000e-3,
    1.000e+0, 1.000e+1, 1.000e+10
  ];
  const eta_default = [
    0.000e+0, 8.500e-1, 9.700e-1, 9.900e-1, 1.000e+0,
    9.900e-1, 9.700e-1, 5.000e-1, 1.000e-1, 0.000e+0,
    0.000e+0, 0.000e+0, 0.000e+0
  ];

  // --- DIF curve (ported exactly)
  const fco = 1450;
  const esco = 0.00003;

  const alpha_DIF = 1 / (5 + 9 * fc_psi / fco);
  const gamma = Math.pow(10, (6.156 * alpha_DIF - 2));

  const esc = [0, 3e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1.0, 3, 10, 30, 100, 300, 3.0e+5];
  const est = [3.0e+4, 3.0e+2, 1.0e+2, 3.0e+1, 1.0e+1, 3.0, 1.0, 1.0e-1, 1.0e-2, 1.0e-3, 1.0e-4, 1.0e-5];

  const es_DIF = [...est.map(v => -v), ...esc];
  const DIF = new Array(es_DIF.length).fill(0);

  // compression DIF part
  for (let idx = est.length; idx < est.length + esc.length; idx++) {
    const val = esc[idx - est.length];
    if (val <= 1e5) DIF[idx] = Math.pow(val / esco, (1.026 * alpha_DIF));
    else DIF[idx] = gamma * Math.pow(val / esco, (1 / 3));
  }
  DIF[est.length] = 1.0;

  // tension DIF part
  const esto = 1.0e-6;
  const delta = 1 / (1 + 8 * fc_psi / fco);
  const beta = Math.pow(10, (6 * delta - 2));

  for (let idx = 0; idx < est.length; idx++) {
    const val = est[idx];
    if (val <= 1.0) DIF[idx] = Math.pow(val / esto, delta);
    else DIF[idx] = beta * Math.pow(val / esto, (1 / 3));
  }

  // --- EOS table (defaults then converted to MPa)
  const ev = [0, -1.5e-3, -4.3e-3, -1.01e-2, -3.05e-2, -5.13e-2, -7.26e-2, -9.43e-2, -1.74e-1, -2.08e-1];

  const Pv_default = [
    0, 3.39976496e3, 7.41148762e3, 1.18991774e4, 2.26084370e4,
    3.40996426e4, 4.83786555e4, 7.40128833e4, 4.32110127e5, 6.60914309e5
  ];
  const Kun_default = [
    2.26650998e6, 2.26650998e6, 2.29824112e6, 2.41383313e6, 2.87166814e6,
    3.33176967e6, 3.78960468e6, 4.13638071e6, 9.30628996e6, 1.13325499e7
  ];

  // Convert to MPa (psi -> MPa)
  const Pv = Pv_default.map(v => v * MPA);
  const Kun = Kun_default.map(v => v * MPA);

  // --- Convert some params to output units like Python does
  const fta = ftm * MPA;
  const a0mn = a0mn_psi * MPA;
  const a2mn = a2mn_psiInv / MPA;

  const a0yn = a0yn_psi * MPA;
  const a2yn = a2yn_psiInv / MPA;

  const a2fn = a2fn_psiInv / MPA;

  // W_conv = W * INCH (inch -> mm)
  const W_conv = W * INCH;

  // --- Title exactly like you did for CSCM style
  const title = `KCC Concrete, fc=${fc_mpa.toFixed(1)}MPa, dmax=${elm_size_mm.toFixed(0)}mm`;

  // --- Keyword render (match your Python writing layout)
  const lines = [];
  lines.push(`$# LS-DYNA Keyword file created by LS-PrePost`);
  lines.push(`*KEYWORD`);
  lines.push(`$ --+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8`);
  lines.push(`$                                                                              $`);
  lines.push(`$                                MATERIAL CARDS                                $`);
  lines.push(`$                                                                              $`);
  lines.push(`$ --+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8`);

  lines.push(`*MAT_CONCRETE_DAMAGE_REL3_TITLE`);
  lines.push(title);
  lines.push(UNITS_LINE);
  REF_LINES.forEach(s => lines.push(s));
  lines.push(HUB_LINE);

  lines.push(`$#     mid        ro        pr`);
  lines.push(`${padInt(mid, 10)}${fmtE(ro, 10, 3)}${fmtE(phr, 10, 1)}`);

  lines.push(`$#      ft        a0        a1        a2        b1     omega       a1f`);
  lines.push(
    `${fmtE(fta, 10, 3)}` +
    `${fmtE(a0mn, 10, 3)}` +
    `${fmtE(a1mn, 10, 3)}` +
    `${fmtE(a2mn, 10, 3)}` +
    `${fmtE(b1, 10, 3)}` +
    `${fmtE(omega, 10, 3)}` +
    `${fmtE(a1fn, 10, 3)}`
  );

  lines.push(`$# slambda      nout     edrop     rsize       ucf    lcrate  locwidth      npts`);
  lines.push(
    `${padInt(100, 10)}` +
    `${padInt(2, 10)}` +
    `${padInt(1, 10)}` +
    `${fmtE(3.972e-2, 10, 3)}` +
    `${fmtE(1.450e+2, 10, 3)}` +
    `${padInt(lcrate, 10)}` +
    `${fmtE(W_conv, 10, 3)}` +
    `${padInt(13, 10)}`
  );

  lines.push(`$# lambda1   lambda2   lambda3   lambda4   lambda5   lambda6   lambda7   lambda8`);
  lines.push(lambda_default.slice(0, 8).map(v => fmtE(v, 10, 3)).join(""));

  lines.push(`$#lambda09  lambda10  lambda11  lambda12  lambda13        b3       a0y       a1y`);
  lines.push(
    lambda_default.slice(8, 13).map(v => fmtE(v, 10, 3)).join("") +
    `${fmtE(b3, 10, 3)}` +
    `${fmtE(a0yn, 10, 3)}` +
    `${fmtE(a1yn, 10, 3)}`
  );

  lines.push(`$#    eta1      eta2      eta3      eta4      eta5      eta6      eta7      eta8`);
  lines.push(eta_default.slice(0, 8).map(v => fmtE(v, 10, 3)).join(""));

  lines.push(`$#   eta09     eta10     eta11     eta12     eta13        b2       a2f       a2y`);
  lines.push(
    eta_default.slice(8, 13).map(v => fmtE(v, 10, 3)).join("") +
    `${fmtE(b2, 10, 3)}` +
    `${fmtE(a2fn, 10, 3)}` +
    `${fmtE(a2yn, 10, 3)}`
  );

  lines.push(`$`);
  lines.push(`*DEFINE_CURVE_TITLE`);
  lines.push(`Dynamic Impact Factors for Tension and Compression`);
  lines.push(`$#    lcid      sidr       sfa       sfo      offa      offo    dattyp`);
  lines.push(
    `${padInt(lcrate, 10)}` +
    `${padInt(0, 10)}` +
    `${padInt(1, 10)}` +
    `${padInt(1, 10)}` +
    `${padInt(0, 10)}` +
    `${padInt(0, 10)}` +
    `${padInt(0, 10)}`
  );
  lines.push(`$#                a1                  o1`);
  for (let i = 0; i < es_DIF.length; i++) {
    lines.push(`${fmtE(es_DIF[i], 20, 3)}${fmtE(DIF[i], 20, 3)}`);
  }

  lines.push(`$`);
  lines.push(`*EOS_TABULATED_COMPACTION`);
  lines.push(`$    EOSID     GAMMA        E0        V0`);
  const GAMMA = 0, EO = 0, VO = 1.0;
  lines.push(`${padInt(eosid, 10)}${fmtE(GAMMA, 10, 3)}${fmtE(EO, 10, 3)}${fmtE(VO, 10, 3)}`);

  lines.push(`$           EV01            EV02            EV03            EV04            EV05`);
  lines.push(ev.slice(0, 5).map(v => fmtE(v, 12, 8)).join(" "));
  lines.push(`$           EV06            EV07            EV08            EV09            EV10`);
  lines.push(ev.slice(5, 10).map(v => fmtE(v, 12, 8)).join(" "));

  lines.push(`$            P01             P02             P03             P04             P05`);
  lines.push(Pv.slice(0, 5).map(v => fmtE(v, 12, 8)).join(" "));
  lines.push(`$            P06             P07             P08             P09             P10`);
  lines.push(Pv.slice(5, 10).map(v => fmtE(v, 12, 8)).join(" "));

  lines.push(`$            T01             T02             T03             T04             T05`);
  lines.push([0,0,0,0,0].map(v => fmtE(v, 12, 8)).join(" "));
  lines.push(`$            T06             T07             T08             T09             T10`);
  lines.push([0,0,0,0,0].map(v => fmtE(v, 12, 8)).join(" "));

  lines.push(`$            K01             K02             K03             K04             K05`);
  lines.push(Kun.slice(0, 5).map(v => fmtE(v, 12, 8)).join(" "));
  lines.push(`$            K06             K07             K08             K09             K10`);
  lines.push(Kun.slice(5, 10).map(v => fmtE(v, 12, 8)).join(" "));

  lines.push(`$`);
  lines.push(`*END`);
  lines.push("");

  const keyword = lines.join("\n");
  const filename = `KCC_fc=${fc_mpa.toFixed(1)}MPa_elm=${elm_size_mm.toFixed(0)}mm_mid=${mid}.k`;
  return { filename, keyword };
}

// ----------------------- helpers -----------------------
function normalizeInput(obj) {
  const out = { ...obj };
  for (const k of Object.keys(out)) if (out[k] === "") out[k] = undefined;
  return out;
}
function mustPositive(name, x) {
  const v = Number(x);
  if (!Number.isFinite(v)) throw new Error(`${name} must be a number`);
  if (v <= 0) throw new Error(`${name} must be > 0`);
  return v;
}
function mustIntPositive(name, x) {
  const v = Number(x);
  if (!Number.isFinite(v)) throw new Error(`${name} must be a number`);
  const vi = Math.trunc(v);
  if (vi <= 0) throw new Error(`${name} must be an integer > 0`);
  return vi;
}
function mustInRange(name, x, lo, hi) {
  const v = Number(x);
  if (!Number.isFinite(v)) throw new Error(`${name} must be a number`);
  if (v < lo || v > hi) throw new Error(`${name} must be in [${lo}, ${hi}]`);
  return v;
}
function padInt(v, width) {
  return String(Math.trunc(v)).padStart(width, " ");
}
function fmtE(v, width = 10, sig = 3) {
  const n = Number(v);
  if (!Number.isFinite(n)) return String(v).padStart(width, " ");
  // mimic python's 10.3E / 10.1E etc
  const s = n.toExponential(sig).replace("e", "E");
  return s.padStart(width, " ");
}
