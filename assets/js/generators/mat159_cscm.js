// assets/js/generators/mat159_cscm.js
// Ported from Python CSCM generator (source of truth)
// Units: mm-ms-g-N-MPa

export const KEY = "mat159_cscm";
export const ID = 159;
export const NAME = "Continuous Surface Cap Model (CSCM) - *MAT_CSCM";
export const CATEGORY = "Concrete";
export const UNITS = "mm-ms-g-N-MPa";

const UNITS_LINE = "$ Units: mm-ms-g-N-MPa";

const REF_LINES = [
  "$ Model: Continuous Surface Cap Model (CSCM) - MAT_159",
  "$ Novozhilov, Y. V., Dmitriev, A. N., & Mikhaluk, D. S. (2022).",
  "$ Precise calibration of the continuous surface cap model for",
  "$ concrete simulation. Buildings, 12(5), 636.",
  "$ DOI: https://doi.org/10.3390/buildings12050636",
];

const HUB_LINE = "$ Generated by LS DYNA Material Hub http://lsdynamat.github.io";

// --- Defaults for UI (you can override in materials.json inputs)
export const DEFAULTS = {
  fc: 30.0,     // MPa
  dmax: 16.0,   // mm
  mid: 1001,    // MID
  ro: 0.0023,   // g/mm^3
  pr: 0.2,      // Poisson ratio (in Python fixed at 0.2, here user can override)
};

// (Optional export) if you later auto-sync forms
export const FIELDS = [
  { key: "fc", label: "Compressive strength (fc)", unit: "MPa", default: DEFAULTS.fc, min: 1, hint: "Example: 30.0" },
  { key: "dmax", label: "Max aggregate size (dmax)", unit: "mm", default: DEFAULTS.dmax, min: 1, hint: "Example: 16" },
  { key: "mid", label: "Material ID (MID)", unit: "-", default: DEFAULTS.mid, min: 1, hint: "Example: 1001" },
  { key: "ro", label: "Density (RO)", unit: "g/mm^3", default: DEFAULTS.ro, min: 1e-6, hint: "Typical: 0.0023" },
  { key: "pr", label: "Poisson ratio (PR)", unit: "-", default: DEFAULTS.pr, min: 0.0, max: 0.49, hint: "Typical: 0.20" },
];

export function generate(input = {}) {
  const inp = { ...DEFAULTS, ...normalizeInput(input) };

  const fc = mustPositive("fc", inp.fc);
  const dmax = mustPositive("dmax", inp.dmax);
  const mid = mustIntPositive("mid", inp.mid);
  const ro = mustPositive("ro", inp.ro);
  const pr = mustInRange("pr", inp.pr, 0.0, 0.49);

  // --- Ported calculations (same as Python)
  const { GF0, GF } = calculateFractureEnergy(fc, dmax);
  const { G, K } = calculateModulus(fc, pr);
  const ab = calculateAlphaBeta(fc);
  const rx = calculateRXd(fc);
  const add = calculateAdditionalParameters(fc);

  // Derived values
  const GFC = 100.0 * GF;
  const GFT = GF;
  const GFS = GF;

  // Fixed constants from Python
  const B = 100.0;
  const D = 0.1;
  const PWRC = 5.0;
  const PWRT = 1.0;
  const PMOD = 0.0;

  const w = 0.065;
  const d1 = 0.000611;
  const d2 = 0.000002;

  // Header fixed fields (from Python write)
  const nplot = 1;
  const incre = 0.0;
  const irate = 0;
  const erode = 1.05;
  const recov = 0.0;
  const itretrc = 0;
  const pred = 0.0;
  const nh = 0.0;
  const ch = 0.0;

  // Requested title style

  const lines = [];
  lines.push(UNITS_LINE);
  REF_LINES.forEach(s => lines.push(s));
  lines.push(HUB_LINE);
  lines.push("*KEYWORD");
  lines.push("*MAT_CSCM_TITLE");
  lines.push(titleLine);
  const titleLine = `Concrete, f_c = ${toFixed(fc, 1)} MPa, d_agg = ${toFixed(dmax, 0)} mm`;
  lines.push("");

  // Same alignment headers as Python
  lines.push("$#     mid        ro     nplot     incre     irate     erode     recov   itretrc");
  lines.push(
    `${fmt10(mid)}` +
    `${fmt10(ro, 4)}` +
    `${fmt10(nplot)}` +
    `${fmt10(incre, 1)}` +
    `${fmt10(irate)}` +
    `${fmt10(erode, 2)}` +
    `${fmt10(recov, 1)}` +
    `${fmt10(itretrc)}`
  );

  lines.push("$#    pred");
  lines.push(`${fmt10(pred, 1)}`);

  lines.push("$#       g         k     alpha     theta     lamda      beta        nh        ch");
  lines.push(
    `${fmt10(G, 1)}` +
    `${fmt10(K, 1)}` +
    `${fmt10(ab.alpha, 4)}` +
    `${fmt10(ab.theta, 7)}` +
    `${fmt10(ab.lamda, 5)}` +
    `${fmt10(ab.beta, 7)}` +
    `${fmt10(nh, 1)}` +
    `${fmt10(ch, 1)}`
  );

  lines.push("$#  alpha1    theta1    lamda1     beta1    alpha2    theta2    lamda2     beta2");
  lines.push(
    `${fmt10(ab.alpha1, 2)}` +
    `${fmt10(ab.theta1, 1)}` +
    `${fmt10(ab.lamda1, 2)}` +
    `${fmt10(ab.beta1, 6)}` +
    `${fmt10(ab.alpha2, 2)}` +
    `${fmt10(ab.theta2, 1)}` +
    `${fmt10(ab.lamda2, 2)}` +
    `${fmt10(ab.beta2, 7)}`
  );

  lines.push("$#       r        xd         w        d1        d2");
  lines.push(
    `${fmt10(rx.R, 5)}` +
    `${fmt10(rx.XD, 3)}` +
    `${fmt10(w, 3)}` +
    `${fmt10(d1, 6)}` +
    `${fmt10(d2, 6)}`
  );

  lines.push("$#       b       gfc         d       gft       gfs      pwrc      pwrt      pmod");
  lines.push(
    `${fmt10(B, 1)}` +
    `${fmt10(GFC, 1)}` +
    `${fmt10(D, 1)}` +
    `${fmt10(GFT, 2)}` +
    `${fmt10(GFS, 2)}` +
    `${fmt10(PWRC, 1)}` +
    `${fmt10(PWRT, 1)}` +
    `${fmt10(PMOD, 1)}`
  );

  lines.push("$#   eta0c        nc     etaot        nt     overc     overt     srate     rep0w");
  lines.push(
    `${fmt10(add.eta0c, 7)}` +
    `${fmt10(add.nc, 2)}` +
    `${fmt10(add.eta0t, 7)}` +
    `${fmt10(add.nt, 2)}` +
    `${fmt10(add.overc, 5)}` +
    `${fmt10(add.overt, 5)}` +
    `${fmt10(add.srate, 1)}` +
    `${fmt10(add.repow, 1)}`
  );

  lines.push("*END");
  lines.push("");

  const keyword = lines.join("\n");
  const filename = `MAT_CSCM_fc=${toFixed(fc, 1)}MPa_dmax=${toFixed(dmax, 1)}mm_mid=${mid}.k`;
  return { filename, keyword };
}

// -----------------------
// Helpers
function normalizeInput(obj) {
  const out = { ...obj };
  for (const k of Object.keys(out)) {
    if (out[k] === "") out[k] = undefined;
  }
  return out;
}

function mustPositive(name, x) {
  const v = Number(x);
  if (!Number.isFinite(v)) throw new Error(`${name} must be a number`);
  if (v <= 0) throw new Error(`${name} must be > 0`);
  return v;
}
function mustIntPositive(name, x) {
  const v = Number(x);
  if (!Number.isFinite(v)) throw new Error(`${name} must be a number`);
  const vi = Math.trunc(v);
  if (vi <= 0) throw new Error(`${name} must be an integer > 0`);
  return vi;
}
function mustInRange(name, x, lo, hi) {
  const v = Number(x);
  if (!Number.isFinite(v)) throw new Error(`${name} must be a number`);
  if (v < lo || v > hi) throw new Error(`${name} must be in [${lo}, ${hi}]`);
  return v;
}
function toFixed(x, n) {
  const v = Number(x);
  if (!Number.isFinite(v)) return String(x);
  return v.toFixed(n);
}
function fmt10(x, decimals = 6) {
  if (Number.isInteger(x)) return String(x).padStart(10, " ");
  const v = Number(x);
  if (!Number.isFinite(v)) return String(x).padStart(10, " ");
  const av = Math.abs(v);
  if (av !== 0 && (av >= 1e6 || av < 1e-4)) {
    return v.toExponential(3).replace("e", "E").padStart(10, " ");
  }
  return v.toFixed(decimals).padStart(10, " ");
}

// -----------------------
// Ported functions (1:1 with Python)
function calculateFractureEnergy(fc, dmax = 16) {
  const delta_f = 8.0;
  const fcm = fc + delta_f;
  const fcm0 = 10.0;

  const GF0 = 0.021 + 5.357e-4 * dmax;
  const GF = GF0 * Math.pow(fcm / fcm0, 0.7);

  return { GF0, GF };
}

function calculateModulus(fc, poisson_ratio = 0.2) {
  const Ec0 = 21.5e3;
  const delta_f = 8.0;
  const fcm = fc + delta_f;
  const fcm0 = 10.0;

  // EXACTLY like your Python: E = Ec0 * ((fcm + delta_f) / fcm0) ** (1/3)
  const E = Ec0 * Math.pow((fcm + delta_f) / fcm0, 1 / 3);

  const G = E / (2 * (1 + poisson_ratio));
  const K = E / (3 * (1 - 2 * poisson_ratio));

  return { G, K };
}

function calculateAlphaBeta(fc) {
  const alpha = 13.9846 * Math.exp(fc / 68.8756) - 13.8981;
  const theta = 0.3533 - 3.3294e-4 * fc - 3.8182e-6 * (fc ** 2);
  const lamda = 3.6657 * Math.exp(fc / 39.9363) - 4.7092;
  const beta = 18.17791 * (fc ** -1.7163);

  const alpha1 = 0.82;
  const theta1 = 0.0;
  const lamda1 = 0.24;
  const beta1 = 0.33565 * (fc ** -0.95383);

  const alpha2 = 0.76;
  const theta2 = 0.0;
  const lamda2 = 0.26;
  const beta2 = 0.285 * (fc ** -0.94843);

  return { alpha, theta, lamda, beta, alpha1, theta1, lamda1, beta1, alpha2, theta2, lamda2, beta2 };
}

function calculateAdditionalParameters(fc) {
  const fpsi = fc * 145.038;

  const eta0c = (1.2772337e-11 * (fpsi ** 2) - 1.0613722e-7 * fpsi + 3.203497e-4);
  const nc = 0.78;

  const eta0t = (8.0614774e-13 * (fc ** 2) - 9.77736719e-10 * fc + 5.0752351e-5);
  const nt = 0.48;

  const overc = 1.309663e-2 * (fc ** 2) - 0.3927659 * fc + 21.45;
  const overt = 1.309663e-2 * (fc ** 2) - 0.3927659 * fc + 21.45;

  const srate = 1.0;
  const repow = 1.0;

  return { eta0c, nc, eta0t, nt, overc, overt, srate, repow };
}

function calculateRXd(fc) {
  const R = 4.45994 * Math.exp(-fc / 11.51679) + 1.95358;
  const XD = 17.087 + 1.892 * fc;
  return { R, XD };
}
