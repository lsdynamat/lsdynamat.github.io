// assets/js/generators/mat159_cscm.js
// CSCM Generator (LS-DYNA *MAT_CSCM, MAT_159)
// Units: mm-s-g-N-MPa

export const KEY = "mat159_cscm";
export const ID = 159;
export const NAME = "CSCM Concrete (*MAT_CSCM)";
export const CATEGORY = "Concrete";
export const UNITS = "mm-s-g-N-MPa";

// --- Header lines (match screenshot)
const PREPOST_LINE = "$# LS-DYNA Keyword file created by LS-PrePost(R) V4.8.17 - 24Jun2021";
const UNITS_LINE = "$ Units: mm-s-g-N-MPa";
const MODEL_LINE = "$ Model: Continuous Surface Cap Model (CSCM) - MAT 159";
const REF_LINE_1 = "$ Reference: Novozhilov Y.V., Dmitriev A.N., Mikhaluk D.S. Precise Calibration";
const REF_LINE_2 = "$ of the Continuous Surface Cap Model for Concrete Simulation. Buildings. 2022.";
const DOI_LINE = "$ doi:10.3390/buildings12050636";
const GEN_LINE = "$ Generated by LSDYNA Material hub https://lsdynamat.github.io/";

// --- Defaults shown in UI
export const DEFAULTS = {
  fc: 30.0,     // MPa
  dmax: 16.0,   // mm
  mid: 465,     // example MID
  ro: 0.0023,   // g/mm^3
  pr: 0.2,      // Poisson ratio
};

// Optional: used if you ever want to auto-sync forms from the generator itself
export const FIELDS = [
  { key: "mid", label: "Material ID (MID)", unit: "-", default: DEFAULTS.mid, min: 1, hint: "Example: 465" },
  { key: "fc", label: "Compressive strength (fc)", unit: "MPa", default: DEFAULTS.fc, min: 1, hint: "Example: 30.0" },
  { key: "dmax", label: "Max aggregate size (dmax)", unit: "mm", default: DEFAULTS.dmax, min: 1, hint: "Example: 16" },
  { key: "ro", label: "Density (RO)", unit: "g/mm^3", default: DEFAULTS.ro, min: 1e-9, hint: "Typical: 0.0023" },
  { key: "pr", label: "Poisson ratio (PR)", unit: "-", default: DEFAULTS.pr, min: 0.0, max: 0.49, hint: "Typical: 0.20" },
];

export function generate(input = {}) {
  const inp = { ...DEFAULTS, ...normalizeInput(input) };

  const mid = mustIntPositive("mid", inp.mid);
  const fc = mustPositive("fc", inp.fc);
  const dmax = mustPositive("dmax", inp.dmax);
  const ro = mustPositive("ro", inp.ro);
  const pr = mustInRange("pr", inp.pr, 0.0, 0.49);

  // --- Ported calculations (same as Python)
  const { GF } = calculateFractureEnergy(fc, dmax);
  const { G, K } = calculateModulus(fc, pr);
  const ab = calculateAlphaBeta(fc);
  const rx = calculateRXd(fc);
  const add = calculateAdditionalParameters(fc);

  // Derived values
  const GFC = 100.0 * GF;
  const GFT = GF;
  const GFS = GF;

  // Fixed constants (Python)
  const nplot = 1;
  const incre = 0.0;
  const irate = 0;
  const erode = 1.05;
  const recov = 0.0;
  const itretrc = 0;
  const pred = 0.0;

  const w = 0.065;
  const d1 = 0.000611;
  const d2 = 0.000002;

  const B = 100.0;
  const D = 0.1;
  const PWRC = 5.0;
  const PWRT = 1.0;
  const PMOD = 0.0;

  const nh = 0.0;
  const ch = 0.0;

  // --- Title lines (match screenshot vibe)
  const createdLine = `$# Created on ${formatCreatedNow()}`;
  const titleMat = `MAT_CSCM_${fc.toFixed(1)}MPa`;
  const matTitleLine = `MAT Concrete CSCM, fc= ${fc.toFixed(1)}MPa, dmax = ${dmax.toFixed(0)}mm`;

  const lines = [];

  // Header like LS-PrePost
  lines.push(PREPOST_LINE);
  lines.push(createdLine);
  lines.push("*KEYWORD");
  lines.push("*TITLE");
  lines.push("$#                                                                         title");
  lines.push("LS-DYNA keyword deck by LS-PrePost");
  lines.push("*MAT_CSCM_TITLE");
  lines.push(titleMat);

  // Meta lines (as in screenshot)
  lines.push(UNITS_LINE);
  lines.push(MODEL_LINE);
  lines.push(REF_LINE_1);
  lines.push(REF_LINE_2);
  lines.push(DOI_LINE);
  lines.push(GEN_LINE);

  // Data block (with column width 10 like LS-PrePost)
  lines.push("$#     mid        ro     nplot     incre     irate     erode     recov   itretrc");
  lines.push(
    f10i(mid) +
    f10(ro, 4, true) +   // ro keeps 0.0023, no sci
    f10i(nplot) +
    f10(incre, 1, true) +
    f10i(irate) +
    f10(erode, 2, true) +
    f10(recov, 1, true) +
    f10i(itretrc)
  );

  lines.push("$#    pred");
  lines.push(f10(pred, 1, true));

  lines.push("$#       g         k     alpha     theta     lamda      beta        nh        ch");
  lines.push(
    f10(G, 1, true) +
    f10(K, 1, true) +
    f10(ab.alpha, 4, true) +
    f10(ab.theta, 7, true) +
    f10(ab.lamda, 5, true) +
    f10(ab.beta, 7, true) +
    f10(nh, 1, true) +
    f10(ch, 1, true)
  );

  lines.push("$#  alpha1    theta1    lamda1     beta1    alpha2    theta2    lamda2     beta2");
  lines.push(
    f10(ab.alpha1, 2, true) +
    f10(ab.theta1, 1, true) +
    f10(ab.lamda1, 2, true) +
    f10(ab.beta1, 6, true) +
    f10(ab.alpha2, 2, true) +
    f10(ab.theta2, 1, true) +
    f10(ab.lamda2, 2, true) +
    f10(ab.beta2, 7, true)
  );

  lines.push("$#       r        xd         w        d1        d2");
  lines.push(
    f10(rx.R, 5, true) +
    f10(rx.XD, 3, true) +
    f10(w, 4, true) +
    f10sci(d1, 5) +      // 6.11000E-4
    f10sci(d2, 5)        // 2.00000E-6
  );

  lines.push("$#       b       gfc         d       gft       gfs      pwrc      pwrt      pmod");
  lines.push(
    f10(B, 1, true) +
    f10(GFC, 1, true) +
    f10(D, 1, true) +
    f10(GFT, 2, true) +
    f10(GFS, 2, true) +
    f10(PWRC, 1, true) +
    f10(PWRT, 1, true) +
    f10(PMOD, 1, true)
  );

  lines.push("$#   eta0c        nc     etaot        nt     overc     overt     srate     rep0w");
  lines.push(
    f10sci(add.eta0c, 5) +  // 1.00300E-4
    f10(add.nc, 2, true) +
    f10sci(add.eta0t, 5) +  // 5.07000E-5
    f10(add.nt, 2, true) +
    f10(add.overc, 5, true) +
    f10(add.overt, 5, true) +
    f10(add.srate, 1, true) +
    f10(add.repow, 1, true)
  );

  lines.push("*END");

  const keyword = lines.join("\n");

  // filename you wanted earlier (safe + readable)
  const filename = `MAT_CSCM_fc=${fc.toFixed(1)}MPa_dmax=${dmax.toFixed(0)}mm_mid=${mid}.k`;

  return { filename, keyword };
}

/* =========================
   Helpers
   ========================= */

function normalizeInput(obj) {
  const out = { ...obj };
  for (const k of Object.keys(out)) {
    if (out[k] === "") out[k] = undefined;
  }
  return out;
}

function mustPositive(name, x) {
  const v = Number(x);
  if (!Number.isFinite(v)) throw new Error(`${name} must be a number`);
  if (v <= 0) throw new Error(`${name} must be > 0`);
  return v;
}
function mustIntPositive(name, x) {
  const v = Number(x);
  if (!Number.isFinite(v)) throw new Error(`${name} must be a number`);
  const vi = Math.trunc(v);
  if (vi <= 0) throw new Error(`${name} must be an integer > 0`);
  return vi;
}
function mustInRange(name, x, lo, hi) {
  const v = Number(x);
  if (!Number.isFinite(v)) throw new Error(`${name} must be a number`);
  if (v < lo || v > hi) throw new Error(`${name} must be in [${lo}, ${hi}]`);
  return v;
}

// Fixed width column formatting (10 chars)
function f10i(x) {
  return String(Math.trunc(Number(x))).padStart(10, " ");
}
function f10(x, decimals = 6, trim = false) {
  const v = Number(x);
  if (!Number.isFinite(v)) return String(x).padStart(10, " ");
  let s = v.toFixed(decimals);
  if (trim) {
    // keep at least one decimal if decimals>0
    // but do NOT remove decimals aggressively (LS-PrePost look)
    // We keep exact toFixed
  }
  return s.padStart(10, " ");
}

// Scientific formatting like "6.11000E-4" and ALWAYS 5 decimals in mantissa
function f10sci(x, mantissaDecimals = 5) {
  const v = Number(x);
  if (!Number.isFinite(v)) return String(x).padStart(10, " ");

  // Build mantissa/exponent manually to control decimals + exponent sign format
  if (v === 0) return ("0.00000E+0").padStart(10, " "); // rare

  const exp = Math.floor(Math.log10(Math.abs(v)));
  const m = v / Math.pow(10, exp);

  // exponent in LS-PrePost often like E-4 (no leading zero)
  const mantissa = m.toFixed(mantissaDecimals);
  const eSign = exp >= 0 ? "+" : "-";
  const eAbs = Math.abs(exp).toString(); // no leading zeros

  // Example: 6.11000E-4
  const s = `${mantissa}E${eSign}${eAbs}`;
  return s.padStart(10, " ");
}

function formatCreatedNow() {
  // Example wanted: Dec-27-2025 (08:26:24)
  const d = new Date();
  const mon = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"][d.getMonth()];
  const day = String(d.getDate()).padStart(2, "0");
  const year = d.getFullYear();
  const hh = String(d.getHours()).padStart(2, "0");
  const mm = String(d.getMinutes()).padStart(2, "0");
  const ss = String(d.getSeconds()).padStart(2, "0");
  return `${mon}-${day}-${year} (${hh}:${mm}:${ss})`;
}

/* =========================
   Ported Python math (1:1)
   ========================= */

function calculateFractureEnergy(fc, dmax = 16) {
  const delta_f = 8;        // MPa
  const fcm = fc + delta_f; // adjusted
  const fcm0 = 10;          // MPa

  const GF0 = 0.021 + 5.357e-4 * dmax;
  const GF = GF0 * Math.pow(fcm / fcm0, 0.7);

  return { GF0, GF };
}

function calculateModulus(fc, poisson_ratio = 0.2) {
  const Ec0 = 21.5e3;
  const delta_f = 8;
  const fcm = fc + delta_f;
  const fcm0 = 10;

  // EXACT as your Python:
  // E = Ec0 * ((fcm + delta_f) / fcm0) ** (1/3)
  const E = Ec0 * Math.pow((fcm + delta_f) / fcm0, 1 / 3);

  const G = E / (2 * (1 + poisson_ratio));
  const K = E / (3 * (1 - 2 * poisson_ratio));
  return { G, K };
}

function calculateAlphaBeta(fc) {
  const alpha = 13.9846 * Math.exp(fc / 68.8756) - 13.8981;
  const theta = 0.3533 - 3.3294e-4 * fc - 3.8182e-6 * (fc ** 2);
  const lamda = 3.6657 * Math.exp(fc / 39.9363) - 4.7092;
  const beta = 18.17791 * (fc ** -1.7163);

  const alpha1 = 0.82;
  const theta1 = 0.0;
  const lamda1 = 0.24;
  const beta1 = 0.33565 * (fc ** -0.95383);

  const alpha2 = 0.76;
  const theta2 = 0.0;
  const lamda2 = 0.26;
  const beta2 = 0.285 * (fc ** -0.94843);

  return { alpha, theta, lamda, beta, alpha1, theta1, lamda1, beta1, alpha2, theta2, lamda2, beta2 };
}

function calculateAdditionalParameters(fc) {
  const fpsi = fc * 145.038;

  const eta0c = (1.2772337e-11 * (fpsi ** 2) - 1.0613722e-7 * fpsi + 3.203497e-4);
  const nc = 0.78;

  const eta0t = (8.0614774e-13 * (fc ** 2) - 9.77736719e-10 * fc + 5.0752351e-5);
  const nt = 0.48;

  const overc = 1.309663e-2 * (fc ** 2) - 0.3927659 * fc + 21.45;
  const overt = 1.309663e-2 * (fc ** 2) - 0.3927659 * fc + 21.45;

  const srate = 1.0;
  const repow = 1.0;

  return { eta0c, nc, eta0t, nt, overc, overt, srate, repow };
}

function calculateRXd(fc) {
  const R = 4.45994 * Math.exp(-fc / 11.51679) + 1.95358;
  const XD = 17.087 + 1.892 * fc;
  return { R, XD };
}
