// assets/js/generators/mat159_cscm.js
// Continuous Surface Cap Model (CSCM) - MAT_159 (*MAT_CSCM)
// Ported from your Python "source of truth"
// Output format: LS-PrePost style (as you requested)
// Units: mm-s-g-N-MPa

export const KEY = "mat159_cscm";
export const ID = 159;
export const NAME = "Continuous Surface Cap Model (CSCM) - *MAT_CSCM";
export const CATEGORY = "Concrete";
export const UNITS = "mm-s-g-N-MPa";

// ---------- Defaults shown in UI (materials.json should match these keys)
export const DEFAULTS = {
  fc: 30.0,     // MPa
  dmax: 16.0,   // mm (used in GF)
  mid: 465,     // MID (user-controlled)
  ro: 0.0023,   // density
  pr: 0.2       // Poisson's ratio (used in modulus)
};

export const FIELDS = [
  { key: "fc",   label: "Compressive strength (fc)", unit: "MPa",   default: DEFAULTS.fc,   min: 1,     hint: "Example: 30.0" },
  { key: "dmax", label: "Max aggregate size (dmax)", unit: "mm",    default: DEFAULTS.dmax, min: 1,     hint: "Example: 16" },
  { key: "mid",  label: "Material ID (MID)",         unit: "-",     default: DEFAULTS.mid,  min: 1,     hint: "Example: 465" },
  { key: "ro",   label: "Density (RO)",              unit: "g/mm^3", default: DEFAULTS.ro,  min: 1e-9,  hint: "Typical: 0.0023" },
  { key: "pr",   label: "Poisson ratio (PR)",        unit: "-",     default: DEFAULTS.pr,   min: 0.0, max: 0.49, hint: "Typical: 0.20" }
];

// ---------- Reference/header lines as requested
const REF_LINES = [
  "$ Model: Continuous Surface Cap Model (CSCM) - MAT_159",
  "$ Reference: Novozhilov Y.V., Dmitriev A.N., Mikhaluk D.S. Precise Calibration",
  "$ of the Continuous Surface Cap Model for Concrete Simulation. Buildings. 2022.",
  "$ doi:10.3390/buildings12050636",
  "$ Generated by MaterialMap http://materialmap.github.io"
];

const UNITS_LINE = "$ Units: mm-s-g-N-MPa";

// ---------- Main entry
export function generate(input = {}) {
  const inp = { ...DEFAULTS, ...normalizeInput(input) };

  const fc   = mustPositive("fc", inp.fc);
  const dmax = mustPositive("dmax", inp.dmax);
  const mid  = mustIntPositive("mid", inp.mid);
  const ro   = mustPositive("ro", inp.ro);
  const pr   = mustInRange("pr", inp.pr, 0.0, 0.49);

  // --- Ported calculations (from your Python)
  const { GF } = calculateFractureEnergy(fc, dmax);
  const { G, K } = calculateModulus(fc, pr);
  const ab  = calculateAlphaBeta(fc);
  const rx  = calculateRXd(fc);
  const add = calculateAdditionalParameters(fc);

  // Derived values (same as Python)
  const GFC = 100.0 * GF;
  const GFT = GF;
  const GFS = GF;

  // Fixed constants (same as Python)
  const nplot   = 1;
  const incre   = 0.0;
  const irate   = 0;
  const erode   = 1.05;
  const recov   = 0.0;
  const itretrc = 0;
  const pred    = 0.0;

  const nh = 0.0;
  const ch = 0.0;

  const w  = 0.065;
  const d1 = 0.000611;
  const d2 = 0.000002;

  const B    = 100.0;
  const D    = 0.1;
  const PWRC = 5.0;
  const PWRT = 1.0;
  const PMOD = 0.0;

  // ----- LS-PrePost style header (as you requested)
  // Use client local time when running in browser (not hard-coded).
  const createdLine = makeCreatedTimestampLine();

  const titleCard = `MAT_CSCM_${toFixed(fc, 1)}MPa`;

  const lines = [];

  lines.push("$# LS-DYNA Keyword file created by LS-PrePost(R) V4.8.17 - 24Jun2021");
  lines.push(createdLine);
  lines.push("*KEYWORD");
  lines.push("*TITLE");
  lines.push("$#                                                                         title");
  lines.push("LS-DYNA keyword deck by LS-PrePost");
  lines.push("*MAT_CSCM_TITLE");
  lines.push(titleCard);

  lines.push(UNITS_LINE);
  REF_LINES.forEach(s => lines.push(s));

  // ----- Cards (fixed column-like)
  lines.push("$#     mid        ro     nplot     incre     irate     erode     recov   itretrc");
  lines.push(
    fmt10(mid, 0) +
    fmt10(ro, 4, { plain: true }) +
    fmt10(nplot, 0) +
    fmt10(incre, 1, { plain: true }) +
    fmt10(irate, 0) +
    fmt10(erode, 2, { plain: true }) +
    fmt10(recov, 1, { plain: true }) +
    fmt10(itretrc, 0)
  );

  lines.push("$#    pred");
  lines.push(fmt10(pred, 1, { plain: true }));

  lines.push("$#       g         k     alpha     theta     lamda      beta        nh        ch");
  lines.push(
    fmt10(G, 1, { plain: true }) +
    fmt10(K, 1, { plain: true }) +
    fmt10(ab.alpha, 4, { plain: true }) +
    fmt10(ab.theta, 7, { plain: true }) +
    fmt10(ab.lamda, 5, { plain: true }) +
    fmt10(ab.beta, 7, { plain: true }) +
    fmt10(nh, 1, { plain: true }) +
    fmt10(ch, 1, { plain: true })
  );

  lines.push("$#  alpha1    theta1    lamda1     beta1    alpha2    theta2    lamda2     beta2");
  lines.push(
    fmt10(ab.alpha1, 2, { plain: true }) +
    fmt10(ab.theta1, 1, { plain: true }) +
    fmt10(ab.lamda1, 2, { plain: true }) +
    fmt10(ab.beta1, 6, { plain: true }) +
    fmt10(ab.alpha2, 2, { plain: true }) +
    fmt10(ab.theta2, 1, { plain: true }) +
    fmt10(ab.lamda2, 2, { plain: true }) +
    fmt10(ab.beta2, 7, { plain: true })
  );

  lines.push("$#       r        xd         w        d1        d2");
  // keep scientific for tiny numbers to avoid "sticking"
  lines.push(
    fmt10(rx.R, 5, { plain: true }) +
    fmt10(rx.XD, 3, { plain: true }) +
    fmt10(w, 3, { plain: true }) +
    fmt10(d1, 5, { sciIfSmall: true }) +
    fmt10(d2, 5, { sciIfSmall: true })
  );

  lines.push("$#       b       gfc         d       gft       gfs      pwrc      pwrt      pmod");
  lines.push(
    fmt10(B, 1, { plain: true }) +
    fmt10(GFC, 4, { plain: true }) +
    fmt10(D, 1, { plain: true }) +
    fmt10(GFT, 5, { plain: true }) +
    fmt10(GFS, 5, { plain: true }) +
    fmt10(PWRC, 1, { plain: true }) +
    fmt10(PWRT, 1, { plain: true }) +
    fmt10(PMOD, 1, { plain: true })
  );

  lines.push("$#   eta0c        nc     etaot        nt     overc     overt     srate     rep0w");
  lines.push(
    fmt10(add.eta0c, 5, { sciIfSmall: true }) +
    fmt10(add.nc, 2, { plain: true }) +
    fmt10(add.eta0t, 5, { sciIfSmall: true }) +
    fmt10(add.nt, 2, { plain: true }) +
    fmt10(add.overc, 5, { plain: true }) +
    fmt10(add.overt, 5, { plain: true }) +
    fmt10(add.srate, 1, { plain: true }) +
    fmt10(add.repow, 1, { plain: true })
  );

  lines.push("*END");

  const keyword = lines.join("\n");

  // filename requested earlier in your project style
  const filename = `MAT_CSCM_${toFixed(fc, 1)}MPa.k`;

  return { filename, keyword };
}

// ======================================================
// Helpers
// ======================================================

function normalizeInput(obj) {
  const out = { ...obj };
  for (const k of Object.keys(out)) {
    if (out[k] === "") out[k] = undefined;
  }
  return out;
}

function mustPositive(name, x) {
  const v = Number(x);
  if (!Number.isFinite(v)) throw new Error(`${name} must be a number`);
  if (v <= 0) throw new Error(`${name} must be > 0`);
  return v;
}

function mustIntPositive(name, x) {
  const v = Number(x);
  if (!Number.isFinite(v)) throw new Error(`${name} must be a number`);
  const vi = Math.trunc(v);
  if (vi <= 0) throw new Error(`${name} must be an integer > 0`);
  return vi;
}

function mustInRange(name, x, lo, hi) {
  const v = Number(x);
  if (!Number.isFinite(v)) throw new Error(`${name} must be a number`);
  if (v < lo || v > hi) throw new Error(`${name} must be in [${lo}, ${hi}]`);
  return v;
}

function toFixed(x, n) {
  const v = Number(x);
  if (!Number.isFinite(v)) return String(x);
  return v.toFixed(n);
}

/**
 * Fixed-width 10-char field like LS-PrePost decks.
 * Options:
 *  - plain: force fixed decimals (no scientific)
 *  - sciIfSmall: use scientific for very small numbers
 */
function fmt10(x, decimals = 6, opt = {}) {
  const v = Number(x);

  // integers
  if (Number.isFinite(v) && Number.isInteger(v) && decimals === 0) {
    return String(v).padStart(10, " ");
  }

  if (!Number.isFinite(v)) return String(x).padStart(10, " ");

  if (opt.sciIfSmall) {
    const av = Math.abs(v);
    if (av !== 0 && (av < 1e-4 || av >= 1e7)) {
      return v.toExponential(5).replace("e", "E").padStart(10, " ");
    }
  }

  if (opt.plain) {
    return v.toFixed(decimals).padStart(10, " ");
  }

  // default: allow scientific for extreme values
  const av = Math.abs(v);
  if (av !== 0 && (av < 1e-4 || av >= 1e7)) {
    return v.toExponential(3).replace("e", "E").padStart(10, " ");
  }
  return v.toFixed(decimals).padStart(10, " ");
}

// Create: `$# Created on Dec-27-2025 (08:26:24)`
function makeCreatedTimestampLine() {
  const d = new Date();

  const months = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
  const dd = String(d.getDate()).padStart(2, "0");
  const mon = months[d.getMonth()];
  const yyyy = d.getFullYear();

  const hh = String(d.getHours()).padStart(2, "0");
  const mm = String(d.getMinutes()).padStart(2, "0");
  const ss = String(d.getSeconds()).padStart(2, "0");

  return `$# Created on ${mon}-${dd}-${yyyy} (${hh}:${mm}:${ss})`;
}

// ======================================================
// Ported functions (1:1 with your Python equations)
// ======================================================

function calculateFractureEnergy(fc, dmax = 16) {
  const delta_f = 8.0;
  const fcm = fc + delta_f;
  const fcm0 = 10.0;

  const GF0 = 0.021 + 5.357e-4 * dmax;
  const GF = GF0 * Math.pow(fcm / fcm0, 0.7);

  return { GF0, GF };
}

function calculateModulus(fc, poisson_ratio = 0.2) {
  const Ec0 = 21.5e3;
  const delta_f = 8.0;
  const fcm = fc + delta_f;
  const fcm0 = 10.0;

  // EXACTLY like your Python:
  // E = Ec0 * ((fcm + delta_f) / fcm0) ** (1/3)
  const E = Ec0 * Math.pow((fcm + delta_f) / fcm0, 1 / 3);

  const G = E / (2 * (1 + poisson_ratio));
  const K = E / (3 * (1 - 2 * poisson_ratio));

  return { G, K };
}

function calculateAlphaBeta(fc) {
  const alpha = 13.9846 * Math.exp(fc / 68.8756) - 13.8981;
  const theta = 0.3533 - 3.3294e-4 * fc - 3.8182e-6 * (fc ** 2);
  const lamda = 3.6657 * Math.exp(fc / 39.9363) - 4.7092;
  const beta = 18.17791 * (fc ** -1.7163);

  const alpha1 = 0.82;
  const theta1 = 0.0;
  const lamda1 = 0.24;
  const beta1 = 0.33565 * (fc ** -0.95383);

  const alpha2 = 0.76;
  const theta2 = 0.0;
  const lamda2 = 0.26;
  const beta2 = 0.285 * (fc ** -0.94843);

  return { alpha, theta, lamda, beta, alpha1, theta1, lamda1, beta1, alpha2, theta2, lamda2, beta2 };
}

function calculateAdditionalParameters(fc) {
  const fpsi = fc * 145.038;

  const eta0c = (1.2772337e-11 * (fpsi ** 2) - 1.0613722e-7 * fpsi + 3.203497e-4);
  const nc = 0.78;

  const eta0t = (8.0614774e-13 * (fc ** 2) - 9.77736719e-10 * fc + 5.0752351e-5);
  const nt = 0.48;

  const overc = 1.309663e-2 * (fc ** 2) - 0.3927659 * fc + 21.45;
  const overt = 1.309663e-2 * (fc ** 2) - 0.3927659 * fc + 21.45;

  const srate = 1.0;
  const repow = 1.0;

  return { eta0c, nc, eta0t, nt, overc, overt, srate, repow };
}

function calculateRXd(fc) {
  const R = 4.45994 * Math.exp(-fc / 11.51679) + 1.95358;
  const XD = 17.087 + 1.892 * fc;
  return { R, XD };
}
