// assets/js/generators/mat024_piecewise_linear_plasticity.js
// Yun & Gardner (2017) based curve for MAT_024 with post-peak plateau point.
// DOI (Yun & Gardner): 10.1016/j.jcsr.2017.01.024
// Ref (Han et al.):    10.1016/j.istruc.2024.107930
// Units: mm-ms-g-N-MPa

export const KEY = "mat024_piecewise_linear_plasticity";
export const ID = 24;
export const NAME = "Piecewise Linear Plasticity";
export const CATEGORY = "Metals";
export const UNITS = "mm-ms-g-N-MPa";

const HUB_LINE = "$ Generated by LS DYNA Material Hub https://lsdynamat.github.io/";
const UNITS_LINE = "$ Units: mm-ms-g-N-MPa";
const MODEL_LINE = "$ Model: Piecewise Linear Plasticity (Yun & Gardner curve) - MAT_024";
const REF_LINES = [
  "$ Reference: Yun, X., & Gardner, L. (2017). Stress–strain curves for hot-rolled steels.",
  "$ Journal of Constructional Steel Research, 133, 36–46. DOI: 10.1016/j.jcsr.2017.01.024",
  "$ Reference: Han, et al. (2025). S-CN connections in modular construction (experimental + numerical).",
  "$ Structures, 71, 107930. DOI: 10.1016/j.istruc.2024.107930",
  "$ Reference: LS-DYNA Keyword User's Manual — MAT_024",
];

const MATERIAL_CARDS_BANNER = [
  "$ --+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8",
  "$                                                                              $",
  "$                                MATERIAL CARDS                                $",
  "$                                                                              $",
  "$ --+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8",
];

export const DEFAULTS = {
  mid: 1,

  ro: 0.00785,
  E: 210000,
  pr: 0.30,

  fy: 235,
  fu: 360,

  // curve smoothness
  n_elastic: 30,
  n_plateau: 20,
  n_hardening: 80,

  // add one point after peak: eps += delta, sigma = constant
  delta_eps_post: 0.02,

  // Optional Cowper–Symonds (blank/0 => disabled)
  c: "",
  p: "",
};

export const FIELDS = [
  { key: "mid", label: "Material ID (MID)", unit: "-", default: DEFAULTS.mid, min: 1, hint: "Unique positive integer material ID (e.g., 1, 12, 1001)." },

  { key: "ro", label: "Density RO", unit: "g/mm^3", default: DEFAULTS.ro, min: 0, hint: "Steel typical: 0.00785 g/mm^3 (≈7850 kg/m^3)." },
  { key: "E", label: "Young's modulus E", unit: "MPa", default: DEFAULTS.E, min: 1, hint: "Typical steels: 200000–210000 MPa." },
  { key: "pr", label: "Poisson ratio PR", unit: "-", default: DEFAULTS.pr, min: 0, max: 0.499, hint: "Metals typically 0.25–0.33. Keep <0.5." },

  { key: "fy", label: "Yield stress Fy", unit: "MPa", default: DEFAULTS.fy, min: 0, hint: "Yield / 0.2% proof stress from tensile test." },
  { key: "fu", label: "Ultimate stress Fu", unit: "MPa", default: DEFAULTS.fu, min: 0, hint: "Ultimate tensile strength (engineering)." },

  { key: "n_elastic", label: "Points: elastic", unit: "-", default: DEFAULTS.n_elastic, min: 5, hint: "Number of points for elastic segment (smoothness only)." },
  { key: "n_plateau", label: "Points: yield plateau", unit: "-", default: DEFAULTS.n_plateau, min: 3, hint: "Number of points for yield plateau (smoothness only)." },
  { key: "n_hardening", label: "Points: hardening", unit: "-", default: DEFAULTS.n_hardening, min: 10, hint: "Number of points for hardening segment (smoothness only)." },

  { key: "delta_eps_post", label: "Post-peak plateau Δε", unit: "-", default: DEFAULTS.delta_eps_post, min: 0, hint: "Adds one extra point after peak: ε += Δε, σ = const (avoid solver extrapolation). Typical 0.01–0.05." },

  { key: "c", label: "Cowper–Symonds C (optional)", unit: "-", default: DEFAULTS.c, hint: "Leave blank/0 to disable. If enabled, choose C,P from literature/test." },
  { key: "p", label: "Cowper–Symonds P (optional)", unit: "-", default: DEFAULTS.p, hint: "Leave blank/0 to disable. Often P≈5 as a starting point (problem-dependent)." },
];

export function generate(input = {}) {
  const inp = { ...DEFAULTS, ...normalizeInput(input) };

  const mid = mustIntPositive("mid", inp.mid);

  const ro = mustPositive("ro", inp.ro);
  const E = mustPositive("E", inp.E);
  const pr = mustInRange("pr", inp.pr, 0.0, 0.49);

  const fy = mustNonNeg("fy", inp.fy);
  const fu = mustNonNeg("fu", inp.fu);
  if (fu < fy) throw new Error("fu must be >= fy");

  const n_elastic = mustIntMin("n_elastic", inp.n_elastic, 5);
  const n_plateau = mustIntMin("n_plateau", inp.n_plateau, 3);
  const n_hardening = mustIntMin("n_hardening", inp.n_hardening, 10);

  const delta_eps_post = mustNonNeg("delta_eps_post", inp.delta_eps_post);

  // Optional Cowper–Symonds
  const c = readOptionalPositive(inp.c) ?? 0.0;
  const p = readOptionalPositive(inp.p) ?? 0.0;

  // ---- Yun & Gardner strains (engineering) ----
  const eps_y = fy / E;

  const eps_sh_formula = 0.1 * (fy / fu) - 0.055;
  let eps_sh = clamp(eps_sh_formula, 0.015, 0.03);

  const eps_u_formula = 0.6 * (1.0 - fy / fu);
  let eps_u = Math.max(eps_u_formula, 0.06);

  // Safety
  if (eps_sh <= eps_y) eps_sh = eps_y + 1e-4;
  if (eps_u <= eps_sh) eps_u = eps_sh + 1e-3;

  // ---- Build engineering curve (envelope) ----
  // Elastic: [0, eps_y)
  let eps_el = linspace(0, eps_y, n_elastic);
  let sig_el = eps_el.map(eps => E * eps);
  eps_el = eps_el.slice(0, -1);
  sig_el = sig_el.slice(0, -1);

  // Plateau: [eps_y, eps_sh)
  let eps_pl = linspace(eps_y, eps_sh, n_plateau);
  let sig_pl = eps_pl.map(() => fy);
  eps_pl = eps_pl.slice(0, -1);
  sig_pl = sig_pl.slice(0, -1);

  // Hardening: [eps_sh, eps_u]
  const eps_h = linspace(eps_sh, eps_u, n_hardening);
  const sig_h = eps_h.map(eps => {
    const C = (eps - eps_sh) / (eps_u - eps_sh);
    const D = Math.pow(1 + 400 * Math.pow(C, 5), 1 / 5);
    return fy + (fu - fy) * (0.4 * C + 2 * C / D);
  });

  let eng_eps = eps_el.concat(eps_pl, eps_h);
  let eng_sig = sig_el.concat(sig_pl, sig_h);

  // ---- Add ONE post-peak plateau point (constant stress) ----
  // robust peak finding (even if future curve changes)
  let ipk = 0;
  for (let i = 1; i < eng_sig.length; i++) if (eng_sig[i] > eng_sig[ipk]) ipk = i;

  const eps_pk = eng_eps[ipk];
  const sig_pk = eng_sig[ipk];

  eng_eps = eng_eps.slice(0, ipk + 1).concat([eps_pk + delta_eps_post]);
  eng_sig = eng_sig.slice(0, ipk + 1).concat([sig_pk]);

  // ---- True conversion (uniform assumption; paper equations) ----
  const tru_eps = eng_eps.map(eps => Math.log1p(eps));
  const tru_sig = eng_sig.map((sig, i) => sig * (1 + eng_eps[i]));

  // ---- True plastic strain for curve input: eps_p = eps_true - sigma_true/E ----
  let eps_p = tru_eps.map((epsT, i) => {
    const ep = epsT - (tru_sig[i] / E);
    return ep < 0 ? 0 : ep;
  });

  // Start at first index where engineering stress reaches fy (robust)
  let i0 = eng_sig.findIndex(s => s >= fy);
  if (i0 < 0) i0 = 0;

  eps_p = eps_p.slice(i0);
  const sig_true_in = tru_sig.slice(i0);

  // Shift so first plastic strain = 0
  const ep0 = eps_p[0] ?? 0.0;
  eps_p = eps_p.map((v, idx) => (idx === 0 ? 0.0 : v - ep0));

  // Ensure monotonic eps_p (numerical safety)
  for (let i = 1; i < eps_p.length; i++) {
    if (eps_p[i] <= eps_p[i - 1]) eps_p[i] = eps_p[i - 1] + 1e-12;
  }

  // ---- Keyword output ----
  // Convention: LCSS = MID*1000 + 24
  const lcss = mid * 1000 + 24;

  const titleLine =
    `MAT_024 YunGardner fy=${toFixed(fy, 1)}MPa fu=${toFixed(fu, 1)}MPa ` +
    `plateau_dEps=${toFixed(delta_eps_post, 3)} ` +
    `(DOI:10.1016/j.jcsr.2017.01.024)`;

  const curveTitle =
    `LCSS_${lcss} YunGardner true_plastic_vs_true_stress (DOI:10.1016/j.jcsr.2017.01.024;10.1016/j.istruc.2024.107930)`;

  const lines = [];
  lines.push("$# LS-DYNA Keyword file created by LS-PrePost");
  lines.push("*KEYWORD");
  MATERIAL_CARDS_BANNER.forEach(s => lines.push(s));

  lines.push(UNITS_LINE);
  lines.push(MODEL_LINE);
  REF_LINES.forEach(s => lines.push(s));
  lines.push(HUB_LINE);

  // *DEFINE_CURVE: x=true plastic strain, y=true stress
  lines.push("*DEFINE_CURVE_TITLE");
  lines.push(curveTitle);
  lines.push("$#    LCID      SIDR       SFA       SFO      OFFA      OFFO");
  lines.push(
    `${fmt10(lcss)}` +
    `${fmt10(0)}` +
    `${fmt10(1.0, 6)}` +
    `${fmt10(1.0, 6)}` +
    `${fmt10(0.0, 6)}` +
    `${fmt10(0.0, 6)}`
  );
  lines.push("$#                a               o");
  for (let i = 0; i < eps_p.length; i++) {
    lines.push(`${fmt20(eps_p[i], 8)}${fmt20(sig_true_in[i], 6)}`);
  }

  // MAT_024
  lines.push("*MAT_PIECEWISE_LINEAR_PLASTICITY_TITLE");
  lines.push(titleLine);

  const fail = 0.0;
  const tdel = 0.0;

  lines.push("$#     MID        RO         E        PR      SIGY      ETAN      FAIL      TDEL");
  lines.push(
    `${fmt10(mid)}` +
    `${fmt10(ro, 7)}` +
    `${fmt10(E, 1)}` +
    `${fmt10(pr, 6)}` +
    `${fmt10(fy, 6)}` +
    `${fmt10(0.0, 6)}` +     // ETAN not used when LCSS hardening curve is provided
    `${fmt10(fail, 6)}` +
    `${fmt10(tdel, 6)}`
  );

  lines.push("$#       C        P      LCSS      LCSR        VP");
  lines.push(
    `${fmt10(c, 6)}` +
    `${fmt10(p, 6)}` +
    `${fmt10(lcss)}` +
    `${fmt10(0)}` +
    `${fmt10(0)}`
  );

  lines.push("*END");
  lines.push("");

  const filename = `MAT_024_YunGardner_mid=${mid}_fy=${toFixed(fy, 1)}_fu=${toFixed(fu, 1)}.k`;
  return { filename, keyword: lines.join("\n") };
}

// ---------------- helpers ----------------
function clamp(x, lo, hi) {
  return Math.max(lo, Math.min(hi, x));
}
function linspace(a, b, n) {
  if (n <= 1) return [a];
  const arr = new Array(n);
  const step = (b - a) / (n - 1);
  for (let i = 0; i < n; i++) arr[i] = a + step * i;
  return arr;
}
function normalizeInput(obj) {
  const out = { ...obj };
  for (const k of Object.keys(out)) if (out[k] === "") out[k] = "";
  return out;
}
function readOptionalNumber(x) {
  if (x === undefined || x === null) return null;
  const s = String(x).trim();
  if (s === "" || s === "0") return null;
  const v = Number(s);
  if (!Number.isFinite(v) || v === 0) return null;
  return v;
}
function readOptionalPositive(x) {
  const v = readOptionalNumber(x);
  if (v == null || v <= 0) return null;
  return v;
}
function mustPositive(name, x) {
  const v = Number(x);
  if (!Number.isFinite(v) || v <= 0) throw new Error(`${name} must be > 0`);
  return v;
}
function mustNonNeg(name, x) {
  const v = Number(x);
  if (!Number.isFinite(v) || v < 0) throw new Error(`${name} must be >= 0`);
  return v;
}
function mustIntPositive(name, x) {
  const v = Number(x);
  if (!Number.isFinite(v)) throw new Error(`${name} must be a number`);
  const vi = Math.trunc(v);
  if (vi <= 0) throw new Error(`${name} must be an integer > 0`);
  return vi;
}
function mustIntMin(name, x, min) {
  const v = Number(x);
  if (!Number.isFinite(v)) throw new Error(`${name} must be a number`);
  const vi = Math.trunc(v);
  if (vi < min) throw new Error(`${name} must be an integer >= ${min}`);
  return vi;
}
function mustInRange(name, x, lo, hi) {
  const v = Number(x);
  if (!Number.isFinite(v) || v < lo || v > hi) throw new Error(`${name} must be in [${lo}, ${hi}]`);
  return v;
}
function toFixed(x, n) {
  const v = Number(x);
  if (!Number.isFinite(v)) return String(x);
  return v.toFixed(n);
}
function fmt10(x, decimals = 6) {
  if (Number.isInteger(x)) return String(x).padStart(10, " ");
  const v = Number(x);
  if (!Number.isFinite(v)) return String(x).padStart(10, " ");
  const av = Math.abs(v);
  if (av !== 0 && (av >= 1e6 || av < 1e-4)) return v.toExponential(3).replace("e", "E").padStart(10, " ");
  return v.toFixed(decimals).padStart(10, " ");
}
function fmt20(x, decimals = 6) {
  const v = Number(x);
  if (!Number.isFinite(v)) return String(x).padStart(20, " ");
  const av = Math.abs(v);
  if (av !== 0 && (av >= 1e8 || av < 1e-8)) return v.toExponential(6).replace("e", "E").padStart(20, " ");
  return v.toFixed(decimals).padStart(20, " ");
}
