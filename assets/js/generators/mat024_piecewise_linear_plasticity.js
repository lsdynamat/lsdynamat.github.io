// assets/js/generators/mat024_piecewise_linear_plasticity.js
// MAT_024: Yun & Gardner (2017) envelope -> true conversion -> curve: true stress vs true plastic strain
// Minimal inputs: n_plateau + n_hardening only (elastic points are internal).
// Adds a horizontal tail after peak stress ending at eps_p(peak) + tail_d_epsp (default 0.1).
// DOI (Yun & Gardner): 10.1016/j.jcsr.2017.01.024
// Ref (Han et al.):    10.1016/j.istruc.2024.107930
// Units: mm-ms-g-N-MPa

export const KEY = "mat024_piecewise_linear_plasticity";
export const ID = 24;
export const NAME = "Piecewise Linear Plasticity";
export const CATEGORY = "Metals";
export const UNITS = "mm-ms-g-N-MPa";

const HUB_LINE = "$ Generated by LS DYNA Material Hub https://lsdynamat.github.io/";
const UNITS_LINE = "$ Units: mm-ms-g-N-MPa";
const MODEL_LINE = "$ Model: Piecewise Linear Plasticity (Yun & Gardner curve) - MAT_024";
const REF_LINES = [
  "$ Reference: Yun, X., & Gardner, L. (2017). Stress–strain curves for hot-rolled steels.",
  "$ Journal of Constructional Steel Research, 133, 36–46. DOI: 10.1016/j.jcsr.2017.01.024",
  "$ Reference: Han, et al. (2025). S-CN connections in modular construction (experimental + numerical).",
  "$ Structures, 71, 107930. DOI: 10.1016/j.istruc.2024.107930",
  "$ Reference: LS-DYNA Keyword User's Manual — MAT_024",
];

const MATERIAL_CARDS_BANNER = [
  "$ --+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8",
  "$                                                                              $",
  "$                                MATERIAL CARDS                                $",
  "$                                                                              $",
  "$ --+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8",
];

// Internal elastic discretization (hidden from UI)
const N_ELASTIC_INTERNAL = 12;

export const DEFAULTS = {
  mid: 1,

  ro: 0.00785,
  E: 210000,
  pr: 0.30,

  fy: 235,
  fu: 360,

  // USER inputs (keep only what you asked)
  n_plateau: 6,
  n_hardening: 25,

  // Tail length in TRUE PLASTIC STRAIN (end = eps_p(peak) + tail_d_epsp)
  tail_d_epsp: 0.1,
};

export const FIELDS = [
  { key: "mid", label: "Material ID (MID)", unit: "-", default: DEFAULTS.mid, min: 1, hint: "Unique positive integer material ID." },

  { key: "ro", label: "Density RO", unit: "g/mm^3", default: DEFAULTS.ro, min: 0, hint: "Steel typical: 0.00785 g/mm^3." },
  { key: "E", label: "Young's modulus E", unit: "MPa", default: DEFAULTS.E, min: 1, hint: "Typical steels: 200000–210000 MPa." },
  { key: "pr", label: "Poisson ratio PR", unit: "-", default: DEFAULTS.pr, min: 0, max: 0.499, hint: "Metals typically 0.25–0.33." },

  { key: "fy", label: "Yield stress Fy", unit: "MPa", default: DEFAULTS.fy, min: 0, hint: "Yield / 0.2% proof stress from tensile test." },
  { key: "fu", label: "Ultimate stress Fu", unit: "MPa", default: DEFAULTS.fu, min: 0, hint: "Ultimate tensile strength (engineering)." },

  {
    key: "n_plateau",
    label: "Points: yield plateau",
    unit: "-",
    default: DEFAULTS.n_plateau,
    min: 3,
    hint: "Discretization only: number of points on the yield plateau (σ = Fy). More points = smoother curve, not a different material.",
  },
  {
    key: "n_hardening",
    label: "Points: hardening",
    unit: "-",
    default: DEFAULTS.n_hardening,
    min: 10,
    hint: "Discretization only: number of points for the nonlinear hardening part (Fy → Fu). More points = smoother curve.",
  },

  {
    key: "tail_d_epsp",
    label: "Tail length Δεp after peak",
    unit: "-",
    default: DEFAULTS.tail_d_epsp,
    min: 0.0,
    hint: "Adds one final point at εp(peak)+Δεp with constant peak stress to avoid solver extrapolation. Typical 0.05–0.30.",
  },
];

export function generate(input = {}) {
  const inp = { ...DEFAULTS, ...normalizeInput(input) };

  const mid = mustIntPositive("mid", inp.mid);

  const ro = mustPositive("ro", inp.ro);
  const E = mustPositive("E", inp.E);
  const pr = mustInRange("pr", inp.pr, 0.0, 0.49);

  const fy = mustNonNeg("fy", inp.fy);
  const fu = mustNonNeg("fu", inp.fu);
  if (fu < fy) throw new Error("fu must be >= fy");

  const n_plateau = mustIntMin("n_plateau", inp.n_plateau, 3);
  const n_hardening = mustIntMin("n_hardening", inp.n_hardening, 10);

  const tail_d_epsp = mustNonNeg("tail_d_epsp", inp.tail_d_epsp);

  // ---- Yun & Gardner strains (engineering) ----
  const eps_y = fy / E;

  const eps_sh_formula = 0.1 * (fy / fu) - 0.055;
  let eps_sh = clamp(eps_sh_formula, 0.015, 0.03);

  const eps_u_formula = 0.6 * (1.0 - fy / fu);
  let eps_u = Math.max(eps_u_formula, 0.06);

  if (eps_sh <= eps_y) eps_sh = eps_y + 1e-4;
  if (eps_u <= eps_sh) eps_u = eps_sh + 1e-3;

  // ---- Build engineering envelope ----
  // Elastic is internal discretization (not exposed to UI)
  let eps_el = linspace(0, eps_y, N_ELASTIC_INTERNAL);
  let sig_el = eps_el.map(eps => E * eps);
  eps_el = eps_el.slice(0, -1);
  sig_el = sig_el.slice(0, -1);

  // Yield plateau (user-controlled discretization)
  let eps_pl = linspace(eps_y, eps_sh, n_plateau);
  let sig_pl = eps_pl.map(() => fy);
  eps_pl = eps_pl.slice(0, -1);
  sig_pl = sig_pl.slice(0, -1);

  // Hardening (user-controlled discretization)
  const eps_h = linspace(eps_sh, eps_u, n_hardening);
  const sig_h = eps_h.map(eps => {
    const C = (eps - eps_sh) / (eps_u - eps_sh);
    const D = Math.pow(1 + 400 * Math.pow(C, 5), 1 / 5);
    return fy + (fu - fy) * (0.4 * C + 2 * C / D);
  });

  const eng_eps = eps_el.concat(eps_pl, eps_h);
  const eng_sig = sig_el.concat(sig_pl, sig_h);

  // ---- True conversion ----
  const tru_eps = eng_eps.map(eps => Math.log1p(eps));
  const tru_sig = eng_sig.map((sig, i) => sig * (1 + eng_eps[i]));

  // ---- True plastic strain (for curve x-axis) ----
  let eps_p = tru_eps.map((epsT, i) => {
    const ep = epsT - (tru_sig[i] / E);
    return ep < 0 ? 0 : ep;
  });

  // Start at yield (robust)
  let i0 = eng_sig.findIndex(s => s >= fy);
  if (i0 < 0) i0 = 0;

  eps_p = eps_p.slice(i0);
  let sig_true = tru_sig.slice(i0);

  // Shift so first eps_p = 0
  const ep0 = eps_p[0] ?? 0.0;
  eps_p = eps_p.map((v, idx) => (idx === 0 ? 0.0 : v - ep0));

  // Ensure monotonic eps_p
  for (let i = 1; i < eps_p.length; i++) {
    if (eps_p[i] <= eps_p[i - 1]) eps_p[i] = eps_p[i - 1] + 1e-12;
  }

  // ---- Peak stress in output domain ----
  let ipk = 0;
  for (let i = 1; i < sig_true.length; i++) if (sig_true[i] > sig_true[ipk]) ipk = i;
  const sig_pk = sig_true[ipk];

  // Keep only up to peak, then force horizontal tail
  eps_p = eps_p.slice(0, ipk + 1);
  sig_true = sig_true.slice(0, ipk + 1);

  // Horizontal tail ends at eps_p(peak) + tail_d_epsp
  const eps_p_peak = eps_p[eps_p.length - 1];
  const eps_p_tail = eps_p_peak + tail_d_epsp;

  if (tail_d_epsp > 0) {
    eps_p.push(eps_p_tail);
    sig_true.push(sig_pk);
  } else {
    sig_true[sig_true.length - 1] = sig_pk;
  }

  // Final monotonic safety
  for (let i = 1; i < eps_p.length; i++) {
    if (eps_p[i] <= eps_p[i - 1]) eps_p[i] = eps_p[i - 1] + 1e-12;
  }

  // ---- Keyword output ----
  const lcss = mid * 1000 + 24;

  const titleLine =
    `MAT_024 YunGardner fy=${toFixed(fy, 1)}MPa fu=${toFixed(fu, 1)}MPa ` +
    `plateauPts=${n_plateau} hardPts=${n_hardening} tail_d_epsp=${toFixed(tail_d_epsp, 3)} ` +
    `(DOI:10.1016/j.jcsr.2017.01.024)`;

  const curveTitle =
    `LCSS_${lcss} YunGardner true_stress_vs_true_plastic (tail=peak+${toFixed(tail_d_epsp, 3)})`;

  const lines = [];
  lines.push("$# LS-DYNA Keyword file created by LS-PrePost");
  lines.push("*KEYWORD");
  MATERIAL_CARDS_BANNER.forEach(s => lines.push(s));

  lines.push(UNITS_LINE);
  lines.push(MODEL_LINE);
  REF_LINES.forEach(s => lines.push(s));
  lines.push(HUB_LINE);

  lines.push("*DEFINE_CURVE_TITLE");
  lines.push(curveTitle);
  lines.push("$#    LCID      SIDR       SFA       SFO      OFFA      OFFO");
  lines.push(
    `${fmt10(lcss)}` +
    `${fmt10(0)}` +
    `${fmt10(1.0, 6)}` +
    `${fmt10(1.0, 6)}` +
    `${fmt10(0.0, 6)}` +
    `${fmt10(0.0, 6)}`
  );
  lines.push("$#                a               o");
  for (let i = 0; i < eps_p.length; i++) {
    lines.push(`${fmt20(eps_p[i], 8)}${fmt20(sig_true[i], 6)}`);
  }

  lines.push("*MAT_PIECEWISE_LINEAR_PLASTICITY_TITLE");
  lines.push(titleLine);

  // Rate effect disabled (no C,P in UI): output C=P=0
  const fail = 0.0;
  const tdel = 0.0;
  const c = 0.0;
  const p = 0.0;

  lines.push("$#     MID        RO         E        PR      SIGY      ETAN      FAIL      TDEL");
  lines.push(
    `${fmt10(mid)}` +
    `${fmt10(ro, 7)}` +
    `${fmt10(E, 1)}` +
    `${fmt10(pr, 6)}` +
    `${fmt10(fy, 6)}` +
    `${fmt10(0.0, 6)}` +
    `${fmt10(fail, 6)}` +
    `${fmt10(tdel, 6)}`
  );

  lines.push("$#       C        P      LCSS      LCSR        VP");
  lines.push(
    `${fmt10(c, 6)}` +
    `${fmt10(p, 6)}` +
    `${fmt10(lcss)}` +
    `${fmt10(0)}` +
    `${fmt10(0)}`
  );

  lines.push("*END");
  lines.push("");

  const filename =
    `MAT_024_YunGardner_mid=${mid}_fy=${toFixed(fy, 1)}_fu=${toFixed(fu, 1)}_p${n_plateau}_h${n_hardening}_tail=${toFixed(tail_d_epsp, 3)}.k`;

  return { filename, keyword: lines.join("\n") };
}

// ---------------- helpers ----------------
function clamp(x, lo, hi) {
  return Math.max(lo, Math.min(hi, x));
}
function linspace(a, b, n) {
  if (n <= 1) return [a];
  const arr = new Array(n);
  const step = (b - a) / (n - 1);
  for (let i = 0; i < n; i++) arr[i] = a + step * i;
  return arr;
}
function normalizeInput(obj) {
  const out = { ...obj };
  for (const k of Object.keys(out)) if (out[k] === "") out[k] = "";
  return out;
}
function mustPositive(name, x) {
  const v = Number(x);
  if (!Number.isFinite(v) || v <= 0) throw new Error(`${name} must be > 0`);
  return v;
}
function mustNonNeg(name, x) {
  const v = Number(x);
  if (!Number.isFinite(v) || v < 0) throw new Error(`${name} must be >= 0`);
  return v;
}
function mustIntPositive(name, x) {
  const v = Number(x);
  if (!Number.isFinite(v)) throw new Error(`${name} must be a number`);
  const vi = Math.trunc(v);
  if (vi <= 0) throw new Error(`${name} must be an integer > 0`);
  return vi;
}
function mustIntMin(name, x, min) {
  const v = Number(x);
  if (!Number.isFinite(v)) throw new Error(`${name} must be a number`);
  const vi = Math.trunc(v);
  if (vi < min) throw new Error(`${name} must be an integer >= ${min}`);
  return vi;
}
function mustInRange(name, x, lo, hi) {
  const v = Number(x);
  if (!Number.isFinite(v) || v < lo || v > hi) throw new Error(`${name} must be in [${lo}, ${hi}]`);
  return v;
}
function toFixed(x, n) {
  const v = Number(x);
  if (!Number.isFinite(v)) return String(x);
  return v.toFixed(n);
}
function fmt10(x, decimals = 6) {
  if (Number.isInteger(x)) return String(x).padStart(10, " ");
  const v = Number(x);
  if (!Number.isFinite(v)) return String(x).padStart(10, " ");
  const av = Math.abs(v);
  if (av !== 0 && (av >= 1e6 || av < 1e-4)) return v.toExponential(3).replace("e", "E").padStart(10, " ");
  return v.toFixed(decimals).padStart(10, " ");
}
function fmt20(x, decimals = 6) {
  const v = Number(x);
  if (!Number.isFinite(v)) return String(x).padStart(20, " ");
  const av = Math.abs(v);
  if (av !== 0 && (av >= 1e8 || av < 1e-8)) return v.toExponential(6).replace("e", "E").padStart(20, " ");
  return v.toFixed(decimals).padStart(20, " ");
}
