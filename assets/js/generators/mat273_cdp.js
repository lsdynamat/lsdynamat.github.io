// assets/js/generators/mat273_cdp.js
// CDP (LS-DYNA *MAT_CONCRETE_DAMAGE_PLASTIC_MODEL) — MAT_273
// Units: mm-ms-g-N-MPa
// Defaults per your spec: TYPE=1 (bi-linear), BS=1.5
//
// Key fixes:
// - ECC updated to LS-DYNA manual (Jirásek & Bažant) formulation
// - WF updated with Gf unit conversion N/m -> N/mm (divide by 1000)
// - Optional fields accept blank/0 without throwing (auto-compute)

export const KEY = "mat273_cdp";
export const ID = 273;
export const NAME = "CDP Concrete (*MAT_CONCRETE_DAMAGE_PLASTIC_MODEL)";
export const CATEGORY = "Concrete";
export const UNITS = "mm-ms-g-N-MPa";

const HUB_LINE = "$ Generated by LS DYNA Material Hub https://lsdynamat.github.io/";
const UNITS_LINE = "$ Units: mm-ms-g-N-MPa";
const MODEL_LINE = "$ Model: Concrete Damage Plasticity (CDP) - MAT_273";

const REF_LINES = [
  "$ Reference: LS-DYNA Keyword User's Manual — MAT_273",
];

const MATERIAL_CARDS_BANNER = [
  "$ --+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8",
  "$                                                                              $",
  "$                                MATERIAL CARDS                                $",
  "$                                                                              $",
  "$ --+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8",
];

// Fixed defaults (not exposed unless you add inputs)
const FIXED = {
  qh0: 0.30,

  // hardening/ductility/flow defaults
  ah: 0.08,
  bh: 0.003,
  ch: 2.0,
  dh: 1.0e-6,
  as: 15.0,
  df: 0.85,

  // damage defaults
  type: 1.0, // <-- YOUR REQUEST
  bs: 1.5,   // <-- YOUR REQUEST
  wf1_ratio: 0.15,
  ft1_ratio: 0.30,

  // erosion
  failflg: 0.0,

  // confinement presets for EFC
  efc_cover: 0.005,
  efc_core: 0.010,
};

export const DEFAULTS = {
  mid: 1,

  // optional: blank/0 => defaults below
  ro: "", // default 0.0023
  pr: "", // default 0.18
  E: "",  // auto EC2 (using fcm)
  ft: "", // auto from function (your ec2/fib function)

  // optional text
  confinement: "", // blank=cover, "core"=confined
  ecc_mode: "",    // blank=compute ECC, "lsdyna" => ECC=0.0 (solver auto)

  // overrides (blank/0 => auto)
  ecc_override: "",
  wf_override: "",
  efc_override: "",

  // strain-rate
  strflg: "",   // blank/0 => 0
  fc0_rate: "", // blank/0 => if STRFLG=1 -> 10 MPa
};

export const FIELDS = [
  { key: "mid", label: "Material ID (MID)", unit: "-", default: DEFAULTS.mid, min: 1, hint: "Unique positive integer" },
  { key: "fc",  label: "Compressive strength FC (= fcm)", unit: "MPa", default: 30, min: 1, hint: "Mean compressive strength from tests (MPa)" },

  { key: "ro",  label: "Density RO (optional)", unit: "g/mm^3", default: DEFAULTS.ro, hint: "Leave blank/0 to use 0.0023" },
  { key: "pr",  label: "Poisson ratio PR (optional)", unit: "-", default: DEFAULTS.pr, hint: "Leave blank/0 to use 0.18" },
  { key: "E",   label: "Young's modulus E (optional)", unit: "MPa", default: DEFAULTS.E, hint: "Leave blank/0 to auto-compute (EC2 using fcm)" },
  { key: "ft",  label: "Tensile strength FT (optional)", unit: "MPa", default: DEFAULTS.ft, hint: "Leave blank/0 to auto-compute; enter to override" },

  { key: "confinement", label: "Confinement (optional)", unit: "-", default: DEFAULTS.confinement, hint: "Blank=cover (unconfined). Type 'core' for confined." },
  { key: "ecc_mode", label: "ECC mode (optional)", unit: "-", default: DEFAULTS.ecc_mode, hint: "Blank=compute ECC (manual formula). Type 'lsdyna' to write ECC=0 (solver auto)." },

  { key: "ecc_override", label: "ECC override (optional)", unit: "-", default: DEFAULTS.ecc_override, hint: "Leave blank/0 to use ECC mode" },
  { key: "wf_override",  label: "WF override (optional)", unit: "mm", default: DEFAULTS.wf_override, hint: "Leave blank/0 to auto-compute from Gf and FT" },
  { key: "efc_override", label: "EFC override (optional)", unit: "-", default: DEFAULTS.efc_override, hint: "Leave blank/0 to use cover/core preset" },

  { key: "strflg",   label: "STRFLG (optional)", unit: "-", default: DEFAULTS.strflg, hint: "0=no strain-rate, 1=strain-rate dependent" },
  { key: "fc0_rate", label: "FC0 (rate parameter, optional)", unit: "MPa", default: DEFAULTS.fc0_rate, hint: "Only used if STRFLG=1. Leave blank/0 to use 10 MPa." },
];

export function generate(input = {}) {
  const inp = { ...DEFAULTS, ...normalizeInput(input) };

  // required
  const mid = mustIntPositive("mid", inp.mid);
  const fc  = mustPositive("fc", inp.fc);

  // optional with defaults
  const roOv = readOptionalPositive(inp.ro);
  const ro = roOv != null ? roOv : 0.0023;

  const prOv = readOptionalNumber(inp.pr);
  const pr = prOv != null ? mustInRange("pr", prOv, 0.0, 0.49) : 0.18;

  const EOv = readOptionalPositive(inp.E);
  const E = EOv != null ? EOv : calculate_E_ec2_from_fcm(fc);

  const ftOv = readOptionalPositive(inp.ft);
  const ft = ftOv != null ? ftOv : calculate_ft_ec2(fc);

  // confinement -> EFC preset
  const isCore = normalizeConfinement(inp.confinement) === "core";

  // STRFLG + related defaults
  const strflgOv = readOptionalNumber(inp.strflg);
  const strflg = strflgOv != null ? (strflgOv >= 0.5 ? 1.0 : 0.0) : 0.0;

  const hp = (strflg >= 0.5) ? 0.5 : 0.01; // manual recommendation
  const fc0 = (strflg >= 0.5)
    ? (readOptionalPositive(inp.fc0_rate) ?? 10.0)
    : 0.0;

  // EFC
  const efcOv = readOptionalPositive(inp.efc_override);
  const efc = efcOv != null ? efcOv : (isCore ? FIXED.efc_core : FIXED.efc_cover);

  // ECC
  const eccOv = readOptionalPositive(inp.ecc_override);
  const eccMode = normalizeEccMode(inp.ecc_mode);
  let ecc;
  if (eccOv != null) {
    ecc = eccOv;
  } else if (eccMode === "lsdyna") {
    ecc = 0.0; // let LS-DYNA auto-calc per manual when ECC=0
  } else {
    ecc = calculate_ecc_lsdyna_manual(fc, ft); // computed per manual formula
  }

  // WF (bilinear)
  const wfOv = readOptionalPositive(inp.wf_override);
  const wf  = wfOv != null ? wfOv : calculate_wf_cdp(fc, ft); // mm, with Gf N/m->N/mm
  const wf1 = FIXED.wf1_ratio * wf;
  const ft1 = FIXED.ft1_ratio * ft;

  // fixed params
  const qh0 = FIXED.qh0;
  const ah = FIXED.ah;
  const bh = FIXED.bh;
  const ch = FIXED.ch;
  const dh = FIXED.dh;
  const as = FIXED.as;
  const df = FIXED.df;

  const type = FIXED.type;   // 1
  const bs   = FIXED.bs;     // 1.5
  const failflg = FIXED.failflg;

  const tag = isCore ? "CORE(confined)" : "COVER(unconfined)";
  const ftTag = (ftOv != null) ? "FT=manual" : "FT=auto";
  const eTag  = (EOv != null) ? "E=manual"  : "E=auto(EC2)";
  const eccTag = (eccOv != null) ? "ECC=manual" : (eccMode === "lsdyna" ? "ECC=0(auto)" : "ECC=calc(manual)");
  const titleLine = `MAT_273 CDP fc=${toFixed(fc, 1)}MPa, ft=${toFixed(ft, 3)}MPa (${ftTag}), ${tag}, ${eTag}, ${eccTag}`;

  const lines = [];
  lines.push("$# LS-DYNA Keyword file created by LS-PrePost");
  lines.push("*KEYWORD");
  MATERIAL_CARDS_BANNER.forEach(s => lines.push(s));

  lines.push("*MAT_CONCRETE_DAMAGE_PLASTIC_MODEL_TITLE");
  lines.push(titleLine);

  lines.push(UNITS_LINE);
  lines.push(MODEL_LINE);
  REF_LINES.forEach(s => lines.push(s));
  lines.push(HUB_LINE);

  lines.push("$#     MID        RO         E        PR       ECC       QH0        FT        FC");
  lines.push(
    `${fmt10(mid)}` +
    `${fmt10(ro, 7)}` +
    `${fmt10(E, 1)}` +
    `${fmt10(pr, 2)}` +
    `${fmt10(ecc, 6)}` +
    `${fmt10(qh0, 3)}` +
    `${fmt10(ft, 6)}` +
    `${fmt10(fc, 6)}`
  );

  lines.push("$#      HP        AH        BH        CH        DH        AS        DF       FC0");
  lines.push(
    `${fmt10(hp, 6)}` +
    `${fmt10(ah, 6)}` +
    `${fmt10(bh, 6)}` +
    `${fmt10(ch, 6)}` +
    `${fmt10(dh, 6)}` +
    `${fmt10(as, 6)}` +
    `${fmt10(df, 6)}` +
    `${fmt10(fc0, 6)}`
  );

  lines.push("$#    TYPE        BS        WF       WF1       FT1    STRFLG   FAILFLG       EFC");
  lines.push(
    `${fmt10(type, 6)}` +
    `${fmt10(bs, 6)}` +
    `${fmt10(wf, 6)}` +
    `${fmt10(wf1, 6)}` +
    `${fmt10(ft1, 6)}` +
    `${fmt10(strflg, 1)}` +
    `${fmt10(failflg, 6)}` +
    `${fmt10(efc, 6)}`
  );

  lines.push("*END");
  lines.push("");

  const filename = `MAT_273_CDP_fc=${toFixed(fc, 1)}MPa_${isCore ? "core" : "cover"}_mid=${mid}.k`;
  return { filename, keyword: lines.join("\n") };
}

// ------------------------
// FT (your function)
// ------------------------
function calculate_ft_ec2(fc) {
  if (fc <= 50) return 0.3 * Math.pow(fc, 2 / 3);
  return 2.12 * Math.log(1 + 0.1 * (fc + 8));
}

// ------------------------
// E (EC2) using fcm directly (your requirement)
// E = 22000 * (fcm/10)^0.3   [MPa]
function calculate_E_ec2_from_fcm(fcm) {
  return 22000.0 * Math.pow(fcm / 10.0, 0.3);
}

// ------------------------
// ECC per LS-DYNA manual (Jirásek & Bažant):
// fbc = 1.16*fc
// eps = ft*(fbc^2 - fc^2) / (fbc*(fc^2 - ft^2))
// ECC = (1+eps)/(2-eps)
function calculate_ecc_lsdyna_manual(fc, ft) {
  const fbc = 1.16 * fc;
  const denom = fbc * (fc * fc - ft * ft);
  if (Math.abs(denom) < 1e-12) throw new Error("ECC denom ~0; check fc/ft.");
  const eps = (ft * (fbc * fbc - fc * fc)) / denom;
  return (1.0 + eps) / (2.0 - eps);
}

// ------------------------
// WF via fracture energy with unit consistency
// Gf = 73*fc^0.18 [N/m]  -> convert to N/mm by /1000
// WF = 4.444*Gf(N/mm)/ft(MPa)
function calculate_gf_cdp_Nmm(fc) {
  return (73.0 * Math.pow(fc, 0.18)) / 1000.0; // N/mm
}
function calculate_wf_cdp(fc, ft) {
  const Gf = calculate_gf_cdp_Nmm(fc);
  return (4.444 * Gf) / ft; // mm
}

// ------------------------
// helpers
// ------------------------
function normalizeConfinement(x) {
  const v = (x ?? "").toString().trim().toLowerCase();
  if (v === "core" || v === "confined") return "core";
  return "cover";
}
function normalizeEccMode(x) {
  const v = (x ?? "").toString().trim().toLowerCase();
  if (v === "lsdyna" || v === "auto" || v === "solver") return "lsdyna";
  return "calc";
}
function normalizeInput(obj) {
  const out = { ...obj };
  for (const k of Object.keys(out)) {
    if (out[k] === "") out[k] = "";
  }
  return out;
}

// Optional numeric: blank/null/undefined/"0"/0 => null
function readOptionalNumber(x) {
  if (x === undefined || x === null) return null;
  const s = String(x).trim();
  if (s === "" || s === "0") return null;
  const v = Number(s);
  if (!Number.isFinite(v)) return null;
  if (v === 0) return null;
  return v;
}
function readOptionalPositive(x) {
  const v = readOptionalNumber(x);
  if (v == null) return null;
  if (v <= 0) return null;
  return v;
}

function mustPositive(name, x) {
  const v = Number(x);
  if (!Number.isFinite(v)) throw new Error(`${name} must be a number`);
  if (v <= 0) throw new Error(`${name} must be > 0`);
  return v;
}
function mustIntPositive(name, x) {
  const v = Number(x);
  if (!Number.isFinite(v)) throw new Error(`${name} must be a number`);
  const vi = Math.trunc(v);
  if (vi <= 0) throw new Error(`${name} must be an integer > 0`);
  return vi;
}
function mustInRange(name, x, lo, hi) {
  const v = Number(x);
  if (!Number.isFinite(v)) throw new Error(`${name} must be a number`);
  if (v < lo || v > hi) throw new Error(`${name} must be in [${lo}, ${hi}]`);
  return v;
}
function toFixed(x, n) {
  const v = Number(x);
  if (!Number.isFinite(v)) return String(x);
  return v.toFixed(n);
}

// 10-char alignment like LS-PrePost blocks
function fmt10(x, decimals = 6) {
  if (Number.isInteger(x)) return String(x).padStart(10, " ");
  const v = Number(x);
  if (!Number.isFinite(v)) return String(x).padStart(10, " ");
  const av = Math.abs(v);
  if (av !== 0 && (av >= 1e6 || av < 1e-4)) {
    return v.toExponential(3).replace("e", "E").padStart(10, " ");
  }
  return v.toFixed(decimals).padStart(10, " ");
}
