// assets/js/generators/mat273_cdp.js
// Concrete Damage Plasticity (LS-DYNA *MAT_CONCRETE_DAMAGE_PLASTIC_MODEL) — MAT_273
// Card order matches LS-PrePost V4.8.17 input form (3 numeric lines).
// Units: mm-ms-g-N-MPa
//
// Features:
// 1) Dropdown "Confinement": cover (non-confined) vs core (confined) -> auto EFC
// 2) Dropdown "FT method": auto (EC2/fib function) OR manual (user input)
// 3) Paper-style auto-calibration: ECC from fc & ft; WF from Gf(fc) and ft
//
// MID is user input.
//
// FT auto function:
//   if fc<=50: ft=0.3*fc^(2/3); else ft=2.12*ln(1+0.1*(fc+8))
//
// Paper formulas used:
//   fbc = 1.16*fc
//   ECC = ft*(fbc^2-ft^2) / (fbc*(fc^2-ft^2))
//   Gf  = 73*fc^0.18
//   WF  = 4.444*Gf/ft

export const KEY = "mat273_cdp";
export const ID = 273;
export const NAME = "Concrete Damage Plasticity (*MAT_CONCRETE_DAMAGE_PLASTIC_MODEL)";
export const CATEGORY = "Concrete";
export const UNITS = "mm-ms-g-N-MPa";

const HUB_LINE = "$ Generated by LS DYNA Material Hub http://lsdynamat.github.io";
const UNITS_LINE = "$ Units: mm-ms-g-N-MPa";
const MODEL_LINE = "$ Model: CDP - *MAT_CONCRETE_DAMAGE_PLASTIC_MODEL (MAT_273)";
const REF_LINES = [
  "$ References:",
  "$  - LS-DYNA Keyword User's Manual — MAT_273",
  "$  - EC2/fib ft formula (auto option) + paper-style ECC/WF derivations",
];

const MATERIAL_CARDS_BANNER = [
  "$ --+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8",
  "$                                                                              $",
  "$                                MATERIAL CARDS                                $",
  "$                                                                              $",
  "$ --+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8",
];

// Dropdown options
export const CONFINEMENT_OPTIONS = [
  { value: "cover", label: "Non-confined (Cover)" },
  { value: "core", label: "Confined (Core)" },
];

export const FT_METHOD_OPTIONS = [
  { value: "auto_ec2", label: "Auto (EC2/fib function)" },
  { value: "manual", label: "Manual input" },
];

export const DEFAULTS = {
  mid: 1,                  // user input
  confinement: "cover",     // "cover" | "core"
  ftMethod: "auto_ec2",     // "auto_ec2" | "manual"

  ro: 0.0024,               // g/mm^3
  E: 30000.0,               // MPa
  pr: 0.20,

  fc: 30.0,                 // MPa
  ft_manual: 2.9,           // MPa (used when ftMethod="manual")

  ecc: null,                // null -> computed
  qh0: 0.30,

  hp: null,                 // null -> auto from STRFLG (0=>0.01, 1=>0.5)
  ah: 0.08,
  bh: 0.003,
  ch: 2.0,
  dh: 1.0e-6,
  as: 15.0,
  df: 0.85,
  fc0: 0.0,                 // meaningful if STRFLG=1

  type: 1.0,                // 1 = bi-linear recommended
  bs: 1.0,
  wf: null,                 // null -> computed from paper
  wf1: null,                // null -> 0.15*wf when type=1
  ft1: null,                // null -> 0.3*ft when type=1
  strflg: 0.0,              // 0 quasi-static, 1 rate-dependent
  failflg: 0.0,             // 0 no erosion
  efc: null,                // null -> cover/core mapping
};

export const FIELDS = [
  {
    key: "mid",
    label: "Material ID (MID)",
    unit: "-",
    default: DEFAULTS.mid,
    min: 1,
    hint: "Unique positive integer",
  },
  {
    key: "confinement",
    label: "Concrete confinement",
    unit: "-",
    default: DEFAULTS.confinement,
    kind: "select",
    options: CONFINEMENT_OPTIONS,
    hint: "cover=EFC 0.005, core=EFC 0.010 (paper)",
  },
  {
    key: "ftMethod",
    label: "FT method",
    unit: "-",
    default: DEFAULTS.ftMethod,
    kind: "select",
    options: FT_METHOD_OPTIONS,
    hint: "Auto uses EC2/fib function on FC; Manual uses FT_MANUAL",
  },

  { key: "ro", label: "Density (RO)", unit: "g/mm^3", default: DEFAULTS.ro, min: 1e-6 },
  { key: "E", label: "Young's modulus (E)", unit: "MPa", default: DEFAULTS.E, min: 1 },
  { key: "pr", label: "Poisson ratio (PR)", unit: "-", default: DEFAULTS.pr, min: 0.0, max: 0.49 },

  { key: "fc", label: "Compressive strength FC (MPa)", unit: "MPa", default: DEFAULTS.fc, min: 1 },
  {
    key: "ft_manual",
    label: "Tensile strength FT (manual, MPa)",
    unit: "MPa",
    default: DEFAULTS.ft_manual,
    min: 0.001,
    hint: "Only used when FT method = Manual input",
  },

  { key: "ecc", label: "ECC (override)", unit: "-", default: DEFAULTS.ecc, hint: "Leave blank to compute from FC & FT" },
  { key: "qh0", label: "QH0 (FC0/FC)", unit: "-", default: DEFAULTS.qh0, min: 0.0, max: 1.0 },

  { key: "type", label: "TYPE (damage formulation)", unit: "-", default: DEFAULTS.type, hint: "1=bi-linear recommended" },
  { key: "strflg", label: "STRFLG (strain-rate)", unit: "-", default: DEFAULTS.strflg, hint: "0=quasi-static, 1=rate-dependent" },
  { key: "failflg", label: "FAILFLG (erosion)", unit: "-", default: DEFAULTS.failflg, hint: "0 disables erosion (recommended for cyclic)" },

  { key: "wf", label: "WF (override)", unit: "mm", default: DEFAULTS.wf, hint: "Leave blank to compute from paper" },
  { key: "efc", label: "EFC (override)", unit: "-", default: DEFAULTS.efc, hint: "Leave blank to auto from confinement dropdown" },
];

export function generate(input = {}) {
  const inp = { ...DEFAULTS, ...normalizeInput(input) };

  const confinement = normalizeConfinement(inp.confinement);
  const isCore = confinement === "core";

  const mid = mustIntPositive("mid", inp.mid);
  const ro = mustPositive("ro", inp.ro);
  const E = mustPositive("E", inp.E);
  const pr = mustInRange("pr", inp.pr, 0.0, 0.49);
  const fc = mustPositive("fc", inp.fc);

  const ftMethod = normalizeFtMethod(inp.ftMethod);
  const ft =
    ftMethod === "manual"
      ? mustPositive("ft_manual", inp.ft_manual)
      : calculate_ft_ec2(fc);

  const ecc = inp.ecc == null ? computeEccentricity(fc, ft) : mustPositive("ecc", inp.ecc);
  const qh0 = mustInRange("qh0", inp.qh0, 0.0, 1.0);

  const strflg = mustInRange("strflg", inp.strflg, 0.0, 1.0);
  const hp =
    inp.hp == null
      ? (strflg >= 0.5 ? 0.5 : 0.01)
      : mustPositive("hp", inp.hp);

  const ah = mustNumber("ah", inp.ah);
  const bh = mustNumber("bh", inp.bh);
  const ch = mustNumber("ch", inp.ch);
  const dh = mustNumber("dh", inp.dh);
  const as = mustNumber("as", inp.as);
  const df = mustNumber("df", inp.df);
  const fc0 = mustNumber("fc0", inp.fc0);

  const type = mustInRange("type", inp.type, 0.0, 3.0);
  const bs = mustNumber("bs", inp.bs);
  const failflg = mustInRange("failflg", inp.failflg, 0.0, 1.0);

  const wf = inp.wf == null ? computeWfFromPaper(fc, ft) : mustPositive("wf", inp.wf);
  const wf1 = inp.wf1 == null ? (Math.round(type) === 1 ? 0.15 * wf : 0.0) : mustNumber("wf1", inp.wf1);
  const ft1 = inp.ft1 == null ? (Math.round(type) === 1 ? 0.3 * ft : 0.0) : mustNumber("ft1", inp.ft1);

  const efc = inp.efc == null ? (isCore ? 0.01 : 0.005) : mustPositive("efc", inp.efc);

  const tag = isCore ? "CORE(confined)" : "COVER(unconfined)";
  const ftTag = ftMethod === "manual" ? "FT=manual" : "FT=auto(EC2)";
  const titleLine = `MAT CDP (MAT_273) fc=${toFixed(fc, 1)}MPa, ft=${toFixed(ft, 3)}MPa (${ftTag}), ${tag}`;

  const lines = [];
  lines.push("$# LS-DYNA Keyword file created by LS-PrePost");
  lines.push("*KEYWORD");
  MATERIAL_CARDS_BANNER.forEach(s => lines.push(s));

  lines.push("*MAT_CONCRETE_DAMAGE_PLASTIC_MODEL_TITLE");
  lines.push(titleLine);

  lines.push(UNITS_LINE);
  lines.push(MODEL_LINE);
  REF_LINES.forEach(s => lines.push(s));
  lines.push(HUB_LINE);

  lines.push("$#     MID        RO         E        PR       ECC       QH0        FT        FC");
  lines.push(
    `${fmt10(mid)}` +
      `${fmt10(ro, 7)}` +
      `${fmt10(E, 1)}` +
      `${fmt10(pr, 2)}` +
      `${fmt10(ecc, 6)}` +
      `${fmt10(qh0, 3)}` +
      `${fmt10(ft, 6)}` +
      `${fmt10(fc, 6)}`
  );

  lines.push("$#      HP        AH        BH        CH        DH        AS        DF       FC0");
  lines.push(
    `${fmt10(hp, 6)}` +
      `${fmt10(ah, 6)}` +
      `${fmt10(bh, 6)}` +
      `${fmt10(ch, 6)}` +
      `${fmt10(dh, 6)}` +
      `${fmt10(as, 6)}` +
      `${fmt10(df, 6)}` +
      `${fmt10(fc0, 6)}`
  );

  lines.push("$#    TYPE        BS        WF       WF1       FT1    STRFLG   FAILFLG       EFC");
  lines.push(
    `${fmt10(type, 6)}` +
      `${fmt10(bs, 6)}` +
      `${fmt10(wf, 6)}` +
      `${fmt10(wf1, 6)}` +
      `${fmt10(ft1, 6)}` +
      `${fmt10(strflg, 1)}` +
      `${fmt10(failflg, 6)}` +
      `${fmt10(efc, 6)}`
  );

  lines.push("*END");
  lines.push("");

  const filename = `MAT_273_CDP_fc=${toFixed(fc, 1)}MPa_${confinement}_${ftMethod}_mid=${mid}.k`;
  return { filename, keyword: lines.join("\n") };
}

function calculate_ft_ec2(fc) {
  if (fc <= 50) return 0.3 * Math.pow(fc, 2 / 3);
  return 2.12 * Math.log(1 + 0.1 * (fc + 8));
}
function computeEccentricity(fc, ft) {
  const fbc = 1.16 * fc;
  const denom = fbc * (fc * fc - ft * ft);
  if (Math.abs(denom) < 1e-12) throw new Error("ECC denominator ~0; check fc/ft values.");
  return (ft * (fbc * fbc - ft * ft)) / denom;
}
function computeGfFromPaper(fc) {
  return 73.0 * Math.pow(fc, 0.18);
}
function computeWfFromPaper(fc, ft) {
  const Gf = computeGfFromPaper(fc);
  return (4.444 * Gf) / ft;
}

function normalizeConfinement(x) {
  const v = (x ?? "").toString().trim().toLowerCase();
  if (v === "core" || v === "confined") return "core";
  return "cover";
}
function normalizeFtMethod(x) {
  const v = (x ?? "").toString().trim().toLowerCase();
  if (v === "manual") return "manual";
  return "auto_ec2";
}
function normalizeInput(obj) {
  const out = { ...obj };
  for (const k of Object.keys(out)) if (out[k] === "") out[k] = undefined;
  return out;
}
function mustNumber(name, x) {
  const v = Number(x);
  if (!Number.isFinite(v)) throw new Error(`${name} must be a number`);
  return v;
}
function mustPositive(name, x) {
  const v = Number(x);
  if (!Number.isFinite(v)) throw new Error(`${name} must be a number`);
  if (v <= 0) throw new Error(`${name} must be > 0`);
  return v;
}
function mustIntPositive(name, x) {
  const v = Number(x);
  if (!Number.isFinite(v)) throw new Error(`${name} must be a number`);
  const vi = Math.trunc(v);
  if (vi <= 0) throw new Error(`${name} must be an integer > 0`);
  return vi;
}
function mustInRange(name, x, lo, hi) {
  const v = Number(x);
  if (!Number.isFinite(v)) throw new Error(`${name} must be a number`);
  if (v < lo || v > hi) throw new Error(`${name} must be in [${lo}, ${hi}]`);
  return v;
}
function toFixed(x, n) {
  const v = Number(x);
  if (!Number.isFinite(v)) return String(x);
  return v.toFixed(n);
}
function fmt10(x, decimals = 6) {
  if (Number.isInteger(x)) return String(x).padStart(10, " ");
  const v = Number(x);
  if (!Number.isFinite(v)) return String(x).padStart(10, " ");
  const av = Math.abs(v);
  if (av !== 0 && (av >= 1e6 || av < 1e-4)) {
    return v.toExponential(3).replace("e", "E").padStart(10, " ");
  }
  return v.toFixed(decimals).padStart(10, " ");
}
